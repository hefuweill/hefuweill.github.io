---
title: 密码学
date: 2020-08-15 21:34:53
category: 计算机网络
---

## 前言

本文主要记录下密码学的发展史，包括古典密码学和现代密码学，以及签名。 <!-- more -->

## 发展史

密码学主要分为古典密码学，以及现代密码学，区别在于古代没有计算机不能进行复杂的计算，全部只能靠人脑，因此加密方式比较简单。

### 古典密码学

古典密码学主要分为以下两类：

1. 移位式加密

    加密方式：缠绕特定木棒（密码棒）后书写。

    密钥：木棒的尺寸以及规格。

2. 替换式加密

    加密方式：替换文本内容。

    密钥：码表。

移位式加密需要双方有同样规格的加密棒，在书写内容时取一条带子缠绕在加密棒上，然后将带子传递给对方，对方将带子缠绕于同样规格的加密棒就能正确识别信息。如果在传递过程中被截获，由于没有特定的加密棒，能难理解传递的消息。

替换式加密需要双方约定一张码表，比如将字母 A 替换为字母 Z，B 替换为 Y，依次类推，在书写内容时先书写原文，接着按照码表一一进行替换，然后传递给对方，对方参照码表替换就能正确识别信息。如果在传递过程中被截获，由于没有码表，能难理解传递的消息。

### 现代密码学

现代密码学主要分为以下两类：

1. 对称加密
2. 非对称加密

对称加密的特点是双方拥有相同的密钥，发送方使用**加密算法**以及密钥对数据进行加密，接收方使用**解密算法**对数据进行解密。注意：**密钥相同，加密算法和解密算法是不同的**。常见的算法有：DES（已废弃，由于位数太短，可被现代计算机穷举破解）、AES。

非对称加密的特点是双方分别拥有公钥以及该公钥对应的私钥，发送方采用**加密算法**以及公钥对数据进行加密，接收方使用**同样的加密算法**以及私钥对数据进行解密。注意：**密钥不相同，加密算法和解密算法是相同的**，其实还可以使用**私钥对数据加密，使用公钥进行解密，但是注意不要将私钥当做公钥，因为公钥可能可以根据私钥推导出来**。常见的算法有：DSA（只能用于签名，但效率高）、RSA。

#### 那么为什么需要有非对称加密？

原因是对称加密有一个缺点那就是通信双方**需要约定一个密钥**，如果是同一个公司的 App 以及服务端，那么双方就可以私下进行约定，这没什么问题。但是假设 A 需要和 B 进行通信，双方在通信前没有进行任何交流（如浏览器访问一个网站），双方如果想加密传输数据那么就得约定密钥，而如果**明文将密钥传递给对方，那么很有可能被第三方截获，最终导致消息泄露。**

#### 非对称加密是如何解决上述问题的？

假设 A 需要与 B 进行通信，在正式通信前 **A 请求获取 B 的公钥**，B 将自己的公钥发送给 A， 往后 A 发送给 B 的数据全部使用该公钥进行加密，由于中间人无法获取 B 的私钥因此无法破解，这样做解决了 A 发送给 B 的消息泄露，反之 **B 也可以请求获取 A 的公钥**， B 拿到 A 的公钥后所有发送给 A 的消息全部使用 A 的公钥进行加密。由于中间人无法获取 A 的私钥因此无法破解。

原理图如下：

![截屏2020-08-16 下午9.20.56](非对称加密原理.png)				  

#### 上述方式能保证安全吗？

其实还是无法保证通信的安全，至少存在以下两个安全隐患：

1. 当 A 获取 B 的公钥时，中间方进行拦截，首先向 B 请求公钥，拿到后 B 的公钥后，将自己的公钥发送给 A，于是 A 发送的所有数据都使用中间人的公钥进行加密，中间人可以使用其私钥来解密，然后再使用 B 的公钥进行加密发送给 B。反过来也一样。**归根到底问题出在接收方无法确认该公钥是不是期望的发送方发送的。**
2. 中间人即使不进行拦截替换公钥，那么它也可以伪造信息，如使用 B 的公钥加密伪造信息发送给 B，而 B 无法确认该信息是否来自 A。**归根到底问题出在接收方无法确认该信息是不是期望的发送方发送的。**

第一个安全隐患，原理图如下：

![截屏2020-08-16 下午9.28.05](非对称加密bug1.png)

第二个安全隐患，原理图如下：                                                                                                                                                                     ![截屏2020-08-16 下午9.29.46](非对称加密bug2.png)											  

对于第一个问题可以采用证书，第二个问题可以使用签名解决，先看看第二个问题。

## 签名

签名在真实生活中的含义为表示同意、认可、承担责任或义务，一般而言签上名字后就具有法律效力。比如借条上签上借用方姓名就有法律效力。

在计算机中，可以使用一对公私钥实现签名与验证。假设 A 需要对数据进行签名并发送给 B ，首先 A 将原数据使用私钥及非对称加密算法进行加密（**签名过程**），B 使用对应的公钥及非对称加密算法进行解密（**验证过程**），如果数据不是乱码那么就能确认该数据就是 A 发送的，因为别人没有 A 的私钥无法伪造。但是校验乱码不是很可靠，一般而言 A 会将原数据通过 B 公钥加密后的数据以及签名后的数据一并发送给 B，B 解密后如果发现与原数据一致，那么就可以认定该数据是 A 发送的。

原理图如下：

![截屏2020-08-16 下午9.31.45](非对称加密s2.png)

经过这么一步操作，B 接收到信息后只要签名验证通过那么就可以认定发送方就是 A，需要注意一点，数据加密算法和签名加密算法可以不同。

**如果将原数据进行签名后的内容与原数据加密后的内容一并发送给 B，会导致传输的内容翻倍，并且中间人也可以使用 A 的公钥解密签名从而获取到原数据。如何解决这两个问题？其实不需要对源文件直接进行签名，而应该对源文件的指纹（摘要）进行签名，这样就会大大减少传输的内容，同时中间人解密签名后拿到的也只是指纹，没法获取到原数据。**

