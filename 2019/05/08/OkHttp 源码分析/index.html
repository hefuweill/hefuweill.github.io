<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="前言半年前阅读了 Volley 源码，但是现在主流网络请求都是使用 OkHttp + Retrofit + RxJava 甚至 Android 中 HttpUrlConnection 的具体实现都被替换成了 OkHttp，因此打算好好研究下 OkHttp 的源码，本文做为阅读笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp 源码分析">
<meta property="og:url" content="http://yoursite.com/2019/05/08/OkHttp%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="何富威的博客">
<meta property="og:description" content="前言半年前阅读了 Volley 源码，但是现在主流网络请求都是使用 OkHttp + Retrofit + RxJava 甚至 Android 中 HttpUrlConnection 的具体实现都被替换成了 OkHttp，因此打算好好研究下 OkHttp 的源码，本文做为阅读笔记。">
<meta property="article:published_time" content="2019-05-08T05:23:10.000Z">
<meta property="article:modified_time" content="2021-03-07T15:17:57.558Z">
<meta property="article:author" content="何富威">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/08/OkHttp 源码分析/"/>





  <title>OkHttp 源码分析 | 何富威的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8dd458e5cf03e833389caa5705955567";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">何富威的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-Android" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/08/OkHttp%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="何富威">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何富威的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OkHttp 源码分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-08T13:23:10+08:00">
                2019-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>半年前阅读了 Volley 源码，但是现在主流网络请求都是使用 OkHttp + Retrofit + RxJava 甚至 Android 中 HttpUrlConnection 的具体实现都被替换成了 OkHttp，因此打算好好研究下 OkHttp 的源码，本文做为阅读笔记。<a id="more"></a> </p>
<p>注：最近发现 OkHttp 使用 Kotlin 语言进行重写了，于是又重新阅读了一遍源码加深下理解，同时学习下 OkHttp 中 Kotlin 的使用方式，本文改为基于 v4.9.0 版本 <a href="https://github.com/square/okhttp" target="_blank" rel="noopener">官方仓库地址</a></p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>这里只例举基本的同步及异步 Get 请求，详细的请看 <a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">官方文档</a>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">syncGet</span><span class="params">(url: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> request = Request.Builder().url(url).build()</span><br><span class="line">    <span class="keyword">val</span> call = client.newCall(request)</span><br><span class="line">    <span class="keyword">val</span> response = call.execute()</span><br><span class="line">    <span class="keyword">if</span> (response.isSuccessful) &#123;</span><br><span class="line">        println(<span class="string">"Response is successful"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">asyncGet</span><span class="params">(url: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> request = Request.Builder().url(url).build()</span><br><span class="line">    <span class="keyword">val</span> call = client.newCall(request)</span><br><span class="line">    call.enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;&#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (response.isSuccessful) &#123;</span><br><span class="line">                println(<span class="string">"Response is successful"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可知，发送一个基本的 get 请求需要如下几步：</p>
<ol>
<li>创建 <code>OkHttpClient</code> 实例。</li>
<li>创建 <code>Request</code> 实例。</li>
<li>创建 <code>Call</code> 实例。</li>
<li>执行 <code>Call.execute()</code> 或者 <code>Call.enqueue()</code> 。</li>
</ol>
<p>下面按照这四步探索下源码实现。</p>
<h2 id="OkHttpClient-实例的创建"><a href="#OkHttpClient-实例的创建" class="headerlink" title="OkHttpClient 实例的创建"></a>OkHttpClient 实例的创建</h2><p><code>OkHttpClient</code> 实例的创建主要有以下两种方式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> client1 = OkHttpClient()</span><br><span class="line"><span class="keyword">val</span> client2 = OkHttpClient.Builder().build()</span><br></pre></td></tr></table></figure>

<p>一种通过调用无参构造器，另一种通过 <code>OkHttpClient.Builder</code> 类构造。当不需要自定义 <code>OkHttpClient</code> 配置的时候可以采用第一种，如果需要自定义配置那么必须采用第二种。接着分别看看上述两种方式的源码实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">internal</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">  builder: Builder</span><br><span class="line">) : Cloneable, Call.Factory, WebSocket.Factory</span><br><span class="line"><span class="keyword">constructor</span>() : <span class="keyword">this</span>(Builder())</span><br><span class="line"><span class="comment">// OkHttpClient.Builder</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: OkHttpClient = OkHttpClient(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>OkHttpClient</code> 提供了一个主构造器以及一个次构造器，虽然主构造器访问修饰为 <code>internal</code> 没法直接调用，但是上述两种创建 <code>OkHttpClient</code> 实例的方式其实都是调用了主构造器。主构造器对成员变量进行赋值以及执行 <code>init</code> 代码块，代码过多就不展开了，无非就是从 <code>OkHttpClient.Builder</code> 中拷贝对应的参数赋值给其成员变量。下面关注下 <code>OkHttpClient.Builder</code> 的构造器，看看默认的参数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 管理异步请求，限制单主机请求数，以及最大请求数</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> dispatcher: Dispatcher = Dispatcher()</span><br><span class="line">    <span class="comment">// 连接池，复用连接，提高网络传输效率</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> connectionPool: ConnectionPool = ConnectionPool()</span><br><span class="line">    <span class="comment">// 拦截器列表</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> interceptors: MutableList&lt;Interceptor&gt; = mutableListOf()</span><br><span class="line">    <span class="comment">// 网络拦截器列表，一般用于调试</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> networkInterceptors: MutableList&lt;Interceptor&gt; = mutableListOf()</span><br><span class="line">    <span class="comment">// 事件监听工厂，默认无，设置后当相应事件触发后会回调如连接开始、连接结束等</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> eventListenerFactory: EventListener.Factory = EventListener.NONE.asFactory()</span><br><span class="line">    <span class="comment">// 网络连接失败是否进行重试，默认为 true</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> retryOnConnectionFailure = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 认证器，当服务器返回 401 时，会执行其 authenticate 方法，需要用户获取最新凭证后返回一个新的 Request 实例并为其添加 Authorization 请求头，默认不处理认证</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> authenticator: Authenticator = Authenticator.NONE</span><br><span class="line">    <span class="comment">// 是否允许重定向</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> followRedirects = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 是否允许协议切换类的重定向，如从 http 转换为 https，当 followRedirects 为 true 时才生效</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> followSslRedirects = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// Cookie 管理类，默认不处理 Cookie</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> cookieJar: CookieJar = CookieJar.NO_COOKIES</span><br><span class="line">    <span class="comment">// 缓存管理类，默认不处理缓存，OkHttp 提供了 Cache 类可以进行磁盘缓存，需要用可以设置</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> cache: Cache? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// DNS，用于将域名转换为对应的 IP 地址列表，默认使用 InetAddress.getAllByName(HostName)</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> dns: Dns = Dns.SYSTEM</span><br><span class="line">    <span class="comment">// 代理，默认无</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> proxy: Proxy? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 代理选择器，默认系统默认</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> proxySelector: ProxySelector? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 代理认证器，连接代理服务器时会执行器 authenticate 方法，需要用户返回在请求中拼接认证信息</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> proxyAuthenticator: Authenticator = Authenticator.NONE</span><br><span class="line">    <span class="comment">// Socket 工厂，默认实现直接创建 Socket 实例</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> socketFactory: SocketFactory = SocketFactory.getDefault()</span><br><span class="line">    <span class="comment">// SslSocket 工厂，用于创建 SSLSocket(在 Socket 上又盖了一层)，默认无</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> sslSocketFactoryOrNull: SSLSocketFactory? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// Https 证书验证器，默认无</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> x509TrustManagerOrNull: X509TrustManager? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 连接规格，默认包括 MODERN_TLS(用于https)、CLEARTEXT(用于http) </span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> connectionSpecs: List&lt;ConnectionSpec&gt; = DEFAULT_CONNECTION_SPECS</span><br><span class="line">    <span class="comment">// 协议列表，默认包括 Http1.1、Http2.0</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> protocols: List&lt;Protocol&gt; = DEFAULT_PROTOCOLS</span><br><span class="line">    <span class="comment">// 主机名验证器，证书有效校验通过后需要其校验主机名，默认使用单例 OkHostnameVerifier</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> hostnameVerifier: HostnameVerifier = OkHostnameVerifier</span><br><span class="line">    <span class="comment">// 证书固定者，用于提高安全性，添加后证书的 Sha256 值必须包括在其内部 pins 中，否则报错，默认无</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> certificatePinner: CertificatePinner = CertificatePinner.DEFAULT</span><br><span class="line">    <span class="comment">// 证书链清洁工，验证证书链，默认无</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> certificateChainCleaner: CertificateChainCleaner? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> callTimeout = <span class="number">0</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> connectTimeout = <span class="number">10_000</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> readTimeout = <span class="number">10_000</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> writeTimeout = <span class="number">10_000</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> pingInterval = <span class="number">0</span></span><br><span class="line">    <span class="comment">// WebSocket 进行 deflate 压缩的最小消息字节数，默认 1k</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> minWebSocketMessageToCompress = RealWebSocket.DEFAULT_MINIMUM_DEFLATE_SIZE</span><br><span class="line">    <span class="comment">// 路由数据库，存储连接失败的路由，下次不会再选</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> routeDatabase: RouteDatabase? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">constructor</span>(okHttpClient: OkHttpClient) : <span class="keyword">this</span>() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：<strong>我感觉如果使用 Kotlin 写 OkHttp 就可以去除建造者模式，改为使用默认参数的方式</strong>。</p>
<p>可以看到 <code>OkHttpClient.Builder</code> 同样提供了一个主构造器和一个次构造器，次构造器用于拷贝 <code>OkHttpClient</code> ，主构造器执行成员变量的赋值，相关变量的作用及默认值已经做了简单说明。接着来看看第二步 <code>Request</code> 实例的创建。</p>
<h2 id="Request-实例的创建"><a href="#Request-实例的创建" class="headerlink" title="Request 实例的创建"></a>Request 实例的创建</h2><p><code>Request</code> 实例通过 <code>Request.Builder</code> 进行创建的，因此首先看看 <code>Request.Builder</code> 的构造器。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = <span class="string">"GET"</span></span><br><span class="line">        <span class="keyword">this</span>.headers = Headers.Builder()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">constructor</span>(request: Request) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>Request.Builder</code> 同样提供了一个主构造器和一个次构造器，次构造器用于拷贝 <code>Request</code> ，主构造器内部设置了默认请求方法为 GET，并且创建了一个 <code>Headers.Builder</code> 实例用于统一管理请求头。接着看看其 <code>url</code> 方法和 <code>build</code> 方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">url</span><span class="params">(url: <span class="type">String</span>)</span></span>: Builder &#123;</span><br><span class="line">    <span class="comment">// 将 web socket urls 替换成 http urls，便于后续发起协议升级请求</span></span><br><span class="line">    <span class="keyword">val</span> finalUrl: String = <span class="keyword">when</span> &#123;</span><br><span class="line">        url.startsWith(<span class="string">"ws:"</span>, ignoreCase = <span class="literal">true</span>) -&gt; &#123;</span><br><span class="line">            <span class="string">"http:<span class="subst">$&#123;url.substring(<span class="number">3</span>)&#125;</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">        url.startsWith(<span class="string">"wss:"</span>, ignoreCase = <span class="literal">true</span>) -&gt; &#123;</span><br><span class="line">            <span class="string">"https:<span class="subst">$&#123;url.substring(<span class="number">4</span>)&#125;</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; url</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url(finalUrl.toHttpUrl())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">url</span><span class="params">(url: <span class="type">HttpUrl</span>)</span></span>: Builder = apply &#123;</span><br><span class="line">    <span class="keyword">this</span>.url = url</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: Request &#123;</span><br><span class="line">    <span class="keyword">return</span> Request(</span><br><span class="line">        checkNotNull(url) &#123; <span class="string">"url == null"</span> &#125;,</span><br><span class="line">        method,</span><br><span class="line">        headers.build(),</span><br><span class="line">        body,</span><br><span class="line">        tags.toImmutableMap()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：<strong>Kotlin 中如果方法需要返回当前类对象直接使用 <code>apply</code> 方法包裹方法体</strong>。</p>
<p>其中 <code>url</code> 方法主要是将请求地址封装成 <code>HttpUrl</code> 实例并赋值给成员 <code>url</code>，<code>build</code> 方法创建了 <code>Request</code> 实例。至此第二步结束了接着看看第三步 <code>Call</code> 实例的创建。</p>
<h2 id="Call-实例的创建"><a href="#Call-实例的创建" class="headerlink" title="Call 实例的创建"></a>Call 实例的创建</h2><p>通过调用 OkHttpClient 实例的 newCall 方法创建 Call 实例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call = RealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p><code>newCall</code> 方法创建并返回了一个 <code>RealCall</code> 实例，<code>forWebSocket</code> 用于区分是否是 WebSocket 握手请求，这里为 false。至此第三步也结束了看看最后一步 <code>call.execute</code> 以及 <code>call.enqueue</code> 方法是如何进行网络请求的。</p>
<h2 id="Call-execute-和-Call-enqueue"><a href="#Call-execute-和-Call-enqueue" class="headerlink" title="Call.execute 和 Call.enqueue"></a>Call.execute 和 Call.enqueue</h2><p>通过上文可知 <code>Call</code> 的具体实现为 RealCall，首先看看相对而言比较简单的同步请求方法 execute。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RealCall.kt</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">    timeout.enter()</span><br><span class="line">    callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">callStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.callStackTrace = Platform.<span class="keyword">get</span>().getStackTraceForCloseable(<span class="string">"body().close()"</span>)</span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dispatcher.kt</span></span><br><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">executed</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">    runningSyncCalls.add(call)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部执行顺序为：</p>
<ol>
<li>校验该 <code>RealCall</code> 是否已经执行过，如果已经执行过就会抛出异常。</li>
<li>回调 <code>EventListener.onStart</code> 方法。</li>
<li>执行 <code>Dispatcher.executed</code> 方法，仅仅只把当前 <code>RealCall</code> 实例放入 <code>runningSyncCalls</code> 队列中。</li>
<li>执行 <code>getResponseWithInterceptorChain</code> 方法。</li>
</ol>
<p>继续跟踪  <code>getResponseWithInterceptorChain</code> 方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors += client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line">    <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">        call = <span class="keyword">this</span>,</span><br><span class="line">        interceptors = interceptors,</span><br><span class="line">        index = <span class="number">0</span>,</span><br><span class="line">        exchange = <span class="literal">null</span>,</span><br><span class="line">        request = originalRequest,</span><br><span class="line">        connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">        readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">        writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">        <span class="keyword">if</span> (isCanceled()) &#123;</span><br><span class="line">            response.closeQuietly()</span><br><span class="line">            <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">            noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部执行顺序为：</p>
<ol>
<li>拼接所有的 <code>Interceptor</code>，包括 OkHttp 内置的 <code>RetryAndFollowUpInterceptor</code>、 <code>BridgeInterceptor</code>、<code>CacheInterceptor</code>、<code>ConnectInterceptor</code>、<code>CallServerInterceptor</code> 以及用户设置的 <code>interceptors</code> 、<code>networkInterceptors</code>，其中 <code>networkInterceptors</code> 主要用于网络调试，因为其可以获取到服务端返回的原始数据，可用代码库有 <a href="https://github.com/square/okhttp/tree/master/okhttp-logging-interceptor" target="_blank" rel="noopener"><code>HttpLoggingInterceptor</code></a> 、<a href="https://github.com/facebook/stetho" target="_blank" rel="noopener"><code>StethoInterceptor</code></a>。</li>
<li>创建 <code>RealInterceptorChain</code> 实例，并调用其 <code>proceed</code> 方法，获取到 <code>Response</code> 实例返回给外界。</li>
</ol>
<p>继续跟踪 <code>proceed</code> 方法，看看其是如何获取到响应的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response &#123;</span><br><span class="line">    check(index &lt; interceptors.size)</span><br><span class="line">    calls++</span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">        check(exchange.finder.sameHostAndPort(request.url)) &#123;</span><br><span class="line">            <span class="string">"network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must retain the same host and port"</span></span><br><span class="line">        &#125;</span><br><span class="line">        check(calls == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="string">"network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must call proceed() exactly once"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> next = copy(index = index + <span class="number">1</span>, request = request)</span><br><span class="line">    <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">"USELESS_ELVIS"</span>)</span></span><br><span class="line">    <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">        <span class="string">"interceptor <span class="variable">$interceptor</span> returned null"</span>)</span><br><span class="line">    check(response.body != <span class="literal">null</span>) &#123; <span class="string">"interceptor <span class="variable">$interceptor</span> returned a response with no body"</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>proceed</code> 方法实现了 OkHttp 拦截器的链式调用，执行顺序为：</p>
<ol>
<li>校验索引是否越界，如果越界抛出异常。</li>
<li>校验 <code>networkInterceptors</code> 是否修改了主机及端口号。注：<code>exchange</code> 会在 <code>ConnectInterceptor</code> 中赋值。</li>
<li>校验 <code>networkInterceptors</code> 是否没调用 <code>proceed</code> 方法或者调用了多次。</li>
<li>拷贝 <code>RealChainInterceptor</code> 实例，并将其 index 属性加 1。注：<strong>必须拷贝的原因是可以进行重试</strong></li>
<li>获取指定 <code>index</code> 处的 <code>Interceptor</code> 实例，执行其 <code>intercept</code> 方法，将拷贝后的 <code>RealChainInterceptor</code> 实例传入。</li>
<li>校验每个拦截器返回的响应体是否为空。</li>
<li>将调用 <code>intercept</code> 方法获取到的响应进行返回。</li>
</ol>
<p>根据上述逻辑，默认 <code>index</code> 为 0，因此会首先执行 <code>RetryAndFollowInterceptor.intercept</code> 方法，并将 <code>index</code> 为 1 的 <code>RealChainInterceptor</code> 实例传入。 </p>
<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p><code>RetryAndFollowUpInterceptor</code> 主要负责失败重试，以及重定向。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetryAndFollowUpInterceptor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> client: OkHttpClient) : Interceptor &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">        <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">        <span class="keyword">var</span> request = chain.request</span><br><span class="line">        <span class="keyword">val</span> call = realChain.call</span><br><span class="line">        <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;()</span><br><span class="line">        <span class="comment">// 每执行一轮，表示进行一次重试</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建 ExchangeFinder 实例，第一次一定会创建</span></span><br><span class="line">            call.enterNetworkInterceptorExchange(request, newExchangeFinder)</span><br><span class="line">            <span class="keyword">var</span> response: Response</span><br><span class="line">            <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果已经取消了，抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (call.isCanceled()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行下一个 interceptor.intercept 方法</span></span><br><span class="line">                    response = realChain.proceed(request)</span><br><span class="line">                    <span class="comment">// 请求成功，但是可能是一个重定向响应</span></span><br><span class="line">                    newExchangeFinder = <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">                    <span class="comment">// 尝试路由连接异常，如果可恢复，那么重试，否则抛出异常</span></span><br><span class="line">                    <span class="keyword">if</span> (!recover(...)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        recoveredFailures += e.firstConnectException</span><br><span class="line">                    &#125;</span><br><span class="line">                    newExchangeFinder = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                    <span class="comment">// 试图与服务器通信异常，请求可能已经发送，如果可恢复，那么重试，否则抛出异常 </span></span><br><span class="line">                    <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e.withSuppressed(recoveredFailures)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        recoveredFailures += e</span><br><span class="line">                    &#125;</span><br><span class="line">                    newExchangeFinder = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果上个响应存在(表示上个响应是一个重定向响应，其不会拥有响应体)，构建一个新的Response实例将上个响应赋值给priorResponse属性</span></span><br><span class="line">                <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">                    response = response.newBuilder()</span><br><span class="line">                    .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                                   .body(<span class="literal">null</span>)</span><br><span class="line">                                   .build())</span><br><span class="line">                    .build()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">val</span> exchange = call.interceptorScopedExchange</span><br><span class="line">                <span class="comment">// 根据响应构建下次请求的 Request，如果服务端返回 401，则回调 authenticator.authenticate，并将返回的 Request 实例返回</span></span><br><span class="line">            <span class="comment">// 如果服务端返回 301、302 等重定向响应码，则取出 Location 响应头，将其值当做下次请求的 url</span></span><br><span class="line">                <span class="keyword">val</span> followUp = followUpRequest(response, exchange)</span><br><span class="line">                <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 表示不需要重定向和认证，直接返回</span></span><br><span class="line">                    closeActiveExchange = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">return</span> response</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">                <span class="comment">// 如果限制只发送一次，那也直接返回响应</span></span><br><span class="line">                <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">                    closeActiveExchange = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">return</span> response</span><br><span class="line">                &#125;</span><br><span class="line">                response.body?.closeQuietly()</span><br><span class="line">                <span class="comment">// 重定向请求太多了，就抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ProtocolException(<span class="string">"Too many follow-up requests: <span class="variable">$followUpCount</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 赋值新建的请求，保存上一个响应，最终的响应会包含所有前面重定向的响应</span></span><br><span class="line">                request = followUp</span><br><span class="line">                priorResponse = response</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 出现异常或者进行了重试关闭连接</span></span><br><span class="line">                call.exitNetworkInterceptorExchange(closeActiveExchange)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致流程是在一个死循环中，调用传入的 <code>RealChainInterceptor</code> 实例的 <code>proceed</code> 方法获取到响应，如果在获取响应图中发生了异常判断是否需要进行重试，需要则进行下次循环重试，如果成功获取到响应，判断响应码是否为 301、302 等重定向响应码，如是则取出 <code>Location</code> 响应头，将其值当做下次请求的 url，如果响应码为 401，那么执行 <code>Authenticator.authenticat</code>e 方法获取新的 Request 实例。</p>
<p>这里也不是真正请求网络的地方，其也是通过 <code>RealChainInterceptor</code> 实例的 <code>proceed</code> 方法获取的响应，不过该 <code>RealChainInterceptor</code> 的 index 字段已经是 1 了，也就是执行索引为 1 的 <code>Interceptor</code>，也就是 <code>BridgeInterceptor</code>。</p>
<h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><p>BridgeInterceptor 做为应用程序代码和网络代码直接的桥梁，其添加了若干个请求头，并会对网络响应进行 gzip 解压。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BridgeInterceptor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> cookieJar: CookieJar) : Interceptor &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">        <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">        <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line">        <span class="keyword">val</span> body = userRequest.body</span><br><span class="line">        <span class="comment">// 如果有请求体，并且请求头如果没有 Content-Type、Content-length</span></span><br><span class="line">        <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">            <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">                requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">            <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">                requestBuilder.header(<span class="string">"Content-Length"</span>, contentLength.toString())</span><br><span class="line">                requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>)</span><br><span class="line">                requestBuilder.removeHeader(<span class="string">"Content-Length"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加 Host 请求头</span></span><br><span class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Host"</span>, userRequest.url.toHostHeader())</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 添加 Connection 请求头</span></span><br><span class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加 Accept-Encoding 请求头，表示接收 gzip 压缩后的响应</span></span><br><span class="line">        <span class="keyword">var</span> transparentGzip = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">            transparentGzip = <span class="literal">true</span></span><br><span class="line">            requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 CookieJar 中获取该 url 的 cookie</span></span><br><span class="line">        <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">        <span class="comment">// 如果有 Cookie，那么添加 Cookie 请求头</span></span><br><span class="line">        <span class="keyword">if</span> (cookies.isNotEmpty()) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加 UA 请求头</span></span><br><span class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"User-Agent"</span>, userAgent)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line">        <span class="comment">// 保存 Cookie 到 CookieJar 中</span></span><br><span class="line">        cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line">        <span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest)</span><br><span class="line">        <span class="comment">// 如果进行了 gzip 压缩那么进行解压</span></span><br><span class="line">        <span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">            <span class="string">"gzip"</span>.equals(networkResponse.header(<span class="string">"Content-Encoding"</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">            networkResponse.promisesBody()) &#123;</span><br><span class="line">            <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">            <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> gzipSource = GzipSource(responseBody.source())</span><br><span class="line">                <span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">                .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">                .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">                .build()</span><br><span class="line">                responseBuilder.headers(strippedHeaders)</span><br><span class="line">                <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">"Content-Type"</span>)</span><br><span class="line">                responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseBuilder.build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体上就是添加了一些常用的请求头，Host、Connection、User-Agent、Accept-Encoding、Cookie、Content-Type、Content-Length ，然后处理了下 gzip 压缩。</p>
<p>这里也不是真正请求网络的地方，其也是通过 <code>RealChainInterceptor</code> 实例的 <code>proceed</code> 方法获取的响应，不过该 <code>RealChainInterceptor</code> 的 index 字段已经是 2 了，也就是执行索引为 2 的 <code>Interceptor</code>，也就是 <code>CacheInterceptor</code>。</p>
<h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p><code>CacheInterceptor</code> 用于从缓存中获取响应和写响应到缓存。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span></span>(<span class="keyword">internal</span> <span class="keyword">val</span> cache: Cache?) : Interceptor &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">        <span class="keyword">val</span> call = chain.call()</span><br><span class="line">        <span class="comment">// 如果给 OkHttpClient 设置了缓存，那么从里面获取缓存的响应</span></span><br><span class="line">        <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line">        <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line">        <span class="comment">// 这个里面主要是根据请求和缓存的响应判断缓存是否命中</span></span><br><span class="line">        <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">        <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">        <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line">        cache?.trackResponse(strategy)</span><br><span class="line">        <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line">        <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">            cacheCandidate.body?.closeQuietly()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 客户端设置了 only-if-cached，表示只使用缓存而缓存又没有命中因此直接构建一个 Response 返回</span></span><br><span class="line">        <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.Builder()</span><br><span class="line">            .request(chain.request())</span><br><span class="line">            .protocol(Protocol.HTTP_1_1)</span><br><span class="line">            .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">            .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">            .body(EMPTY_RESPONSE)</span><br><span class="line">            .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build().also &#123;</span><br><span class="line">                listener.satisfactionFailure(call, it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缓存命中，构造一个Response实例并将去掉了body 的 cacheResponse 赋值给该实例的 cacheResponse属性</span></span><br><span class="line">        <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .build().also &#123;</span><br><span class="line">                listener.cacheHit(call, it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">            listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">            listener.cacheMiss(call)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            networkResponse = chain.proceed(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 发生了异常需要将缓存响应体关闭</span></span><br><span class="line">            <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">                cacheCandidate.body?.closeQuietly()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有缓存响应并且响应码是 304，就根据返回的响应和缓存的响应构造一个新的响应并且更新下缓存</span></span><br><span class="line">        <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">                <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">                .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">                .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">                .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .networkResponse(stripBody(networkResponse))</span><br><span class="line">                .build()</span><br><span class="line">                networkResponse.body!!.close()</span><br><span class="line">                cache!!.trackConditionalCacheHit()</span><br><span class="line">                cache.update(cacheResponse, response)</span><br><span class="line">                <span class="keyword">return</span> response.also &#123;</span><br><span class="line">                    listener.cacheHit(call, it)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cacheResponse.body?.closeQuietly()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 响应码不是304，则构造一个新的 Response</span></span><br><span class="line">        <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build()</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体上就是从 <code>Cache</code> 中取出保存的响应，然后根据请求和缓存的响应判断缓存是否命中，命中就会直接构建一个新的响应返回，如果没命中(由于响应过期)，则会根据缓存响应的 ETag(对应请求头 if-none-match)、LastModify(对应请求头 if-modified-since) 等响应头去构造当前的请求头，这样当服务器判断资源没变化时可以直接返回 304，框架也只需要更新下缓存的响应头就可以直接返回了。</p>
<p>默认配置的 <code>OkHttpClient</code> 不带任何缓存，但是其提供了一个 <code>Cache</code> 类，如果需要缓存可以进行如下配置</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder().cache(Cache(cacheFile, <span class="number">50</span> * <span class="number">1000</span>)).build()</span><br></pre></td></tr></table></figure>

<p>这里也不是真正请求网络的地方，其也是通过 <code>RealChainInterceptor</code> 实例的 <code>proceed</code> 方法获取的响应，不过该 <code>RealChainInterceptor</code> 的 index 字段已经是 3 了，也就是执行索引为 3 的 <code>Interceptor</code>，也就是 <code>ConnectIntercept</code>。</p>
<h3 id="ConnectIntercept"><a href="#ConnectIntercept" class="headerlink" title="ConnectIntercept"></a>ConnectIntercept</h3><p><code>ConnectIntercept</code> 用于与目标主机创建 TCP 连接，并且进行必要的握手，这也是 OkHttp 最难的地方。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> ConnectInterceptor : Interceptor &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">        <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">        <span class="keyword">val</span> exchange = realChain.call.initExchange(chain)</span><br><span class="line">        <span class="keyword">val</span> connectedChain = realChain.copy(exchange = exchange)</span><br><span class="line">        <span class="keyword">return</span> connectedChain.proceed(realChain.request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部主要是调用了 <code>RealCall.initExchange</code> 方法，获取到一个 <code>Exchange</code> 实例，来跟踪下 <code>initExchange</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">initExchange</span><span class="params">(chain: <span class="type">RealInterceptorChain</span>)</span></span>: Exchange &#123;</span><br><span class="line">    <span class="keyword">val</span> exchangeFinder = <span class="keyword">this</span>.exchangeFinder!!</span><br><span class="line">    <span class="keyword">val</span> codec = exchangeFinder.find(client, chain)</span><br><span class="line">    <span class="keyword">val</span> result = Exchange(<span class="keyword">this</span>, eventListener, exchangeFinder, codec)</span><br><span class="line">    <span class="keyword">this</span>.interceptorScopedExchange = result</span><br><span class="line">    <span class="keyword">this</span>.exchange = result</span><br><span class="line">    <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部会通过调用 <code>ExchangeFinder.find</code> 获取到一个 <code>ExchangeCodec</code> 实例，然后在用它构建一个 <code>Exchange</code> 实例，这里涉及到以下几个类</p>
<ol>
<li><code>ExchangeFinder</code> 用于寻找连接，在 <code>RetryAndFollowUpInterceptor</code> 中创建实例。</li>
<li><code>ExchangeCodec</code> 用于生成和解析报文。拥有两个子类 <code>Http1ExchangeCodec</code>、<code>Http2ExchangeCodec</code>。</li>
<li><code>Exchange</code> 用于传输单个 HTTP 请求和响应，内部借助 <code>ExchangeCodec</code> 生成和解析报文。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    client: <span class="type">OkHttpClient</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    chain: <span class="type">RealInterceptorChain</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: ExchangeCodec &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> resultConnection = findHealthyConnection(</span><br><span class="line">            connectTimeout = chain.connectTimeoutMillis,</span><br><span class="line">            readTimeout = chain.readTimeoutMillis,</span><br><span class="line">            writeTimeout = chain.writeTimeoutMillis,</span><br><span class="line">            pingIntervalMillis = client.pingIntervalMillis,</span><br><span class="line">            connectionRetryEnabled = client.retryOnConnectionFailure,</span><br><span class="line">            doExtensiveHealthChecks = chain.request.method != <span class="string">"GET"</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> resultConnection.newCodec(client, chain)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> RouteException(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部通过调用 <code>findHealthyConnection</code> 寻找可用连接，然后调用 <code>newCodec</code> 返回一个 <code>ExchangeCodec</code> 实例。首先看看 <code>findHealthyConnection</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findHealthyConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    connectionRetryEnabled: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    doExtensiveHealthChecks: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: RealConnection &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> candidate = findConnection(</span><br><span class="line">            connectTimeout = connectTimeout,</span><br><span class="line">            readTimeout = readTimeout,</span><br><span class="line">            writeTimeout = writeTimeout,</span><br><span class="line">            pingIntervalMillis = pingIntervalMillis,</span><br><span class="line">            connectionRetryEnabled = connectionRetryEnabled</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> (candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">            <span class="keyword">return</span> candidate</span><br><span class="line">        &#125;</span><br><span class="line">        candidate.noNewExchanges()</span><br><span class="line">        <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">val</span> routesLeft = routeSelection?.hasNext() ?: <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (routesLeft) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">val</span> routesSelectionLeft = routeSelector?.hasNext() ?: <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (routesSelectionLeft) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">"exhausted all routes"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部是个死循环，又通过调用 <code>findConnection</code> 获取到连接，然后检查是否可用，可用就返回，如果不可用，判断是否有路由还没有尝试，如果全尝试过了就抛出异常，如果还有待尝试的则继续循环。继续跟踪 <code>findConnection</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    connectionRetryEnabled: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>: RealConnection &#123;</span><br><span class="line">    <span class="comment">// 如果取消了抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">    <span class="keyword">val</span> callConnection = call.connection</span><br><span class="line">    <span class="comment">// 表示是重试请求</span></span><br><span class="line">    <span class="keyword">if</span> (callConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> toClose: Socket? = <span class="literal">null</span></span><br><span class="line">        synchronized(callConnection) &#123;</span><br><span class="line">            <span class="comment">// 该连接如果不可用，或者再次请求的主机名和端口号与原先的不同，那么需要准备关闭连接</span></span><br><span class="line">            <span class="keyword">if</span> (callConnection.noNewExchanges || !sameHostAndPort(callConnection.route().address.url)) &#123;</span><br><span class="line">                toClose = call.releaseConnectionNoEvents()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连接仍然可用，那么直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (call.connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            check(toClose == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> callConnection</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭不可用的连接</span></span><br><span class="line">        toClose?.closeQuietly()</span><br><span class="line">        <span class="comment">// 回调 eventListener.connectionReleased</span></span><br><span class="line">        eventListener.connectionReleased(call, callConnection)</span><br><span class="line">    &#125;</span><br><span class="line">    refusedStreamCount = <span class="number">0</span></span><br><span class="line">    connectionShutdownCount = <span class="number">0</span></span><br><span class="line">    otherFailureCount = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 尝试从连接池中获取一个连接</span></span><br><span class="line">    <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">        <span class="comment">// 回调 eventListener.connectionAcquired</span></span><br><span class="line">        eventListener.connectionAcquired(call, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// 下面分析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果请求不是重试或者重定向那么 <code>Call.connection</code> 为 <code>null</code> ，那么尝试从连接池中获取一个连接，先看看 <code>callAcquirePooledConnection</code> 是如何获取的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RealConnectionPool.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callAcquirePooledConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    address: <span class="type">Address</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    call: <span class="type">RealCall</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    routes: <span class="type">List</span>&lt;<span class="type">Route</span>&gt;?,</span></span></span><br><span class="line"><span class="function"><span class="params">    requireMultiplexed: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (connection <span class="keyword">in</span> connections) &#123;</span><br><span class="line">        synchronized(connection) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requireMultiplexed &amp;&amp; !connection.isMultiplexed) <span class="keyword">return</span><span class="symbol">@synchronized</span></span><br><span class="line">            <span class="keyword">if</span> (!connection.isEligible(address, routes)) <span class="keyword">return</span><span class="symbol">@synchronized</span></span><br><span class="line">            call.acquireConnectionNoEvents(connection)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RealConnection.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">acquireConnectionNoEvents</span><span class="params">(connection: <span class="type">RealConnection</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.connection = connection</span><br><span class="line">    connection.calls.add(CallReference(<span class="keyword">this</span>, callStackTrace))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历所有连接，由于首次 <code>requireMultiplexed</code> (是否需要多路复用) 为 false，因此执行 <code>RealConnection.isEligible</code> 判断连接是否可用</p>
<ol>
<li>如果可用那么执行 <code>RealCall.acquireConnectionNoEvents</code> 将该连接赋值给 <code>RealCall.connection</code> 字段并返回 true</li>
<li>如果所有连接都不可用那么返回 false</li>
</ol>
<p>接下来看看到底是如何判断连接是否可用的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RealConnection.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEligible</span><span class="params">(address: <span class="type">Address</span>, routes: <span class="type">List</span>&lt;<span class="type">Route</span>&gt;?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (calls.size &gt;= allocationLimit || noNewExchanges) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.route.address.equalsNonHost(address)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (address.url.host == <span class="keyword">this</span>.route().address.url.host) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (http2Connection == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (routes == <span class="literal">null</span> || !routeMatchesAny(routes)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (address.hostnameVerifier !== OkHostnameVerifier) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (!supportsUrl(address.url)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        address.certificatePinner!!.check(address.url.host, handshake()!!.peerCertificates)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_: SSLPeerUnverifiedException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">equalsNonHost</span><span class="params">(that: <span class="type">Address</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dns == that.dns &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.proxyAuthenticator == that.proxyAuthenticator &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.protocols == that.protocols &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.connectionSpecs == that.connectionSpecs &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.proxySelector == that.proxySelector &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.proxy == that.proxy &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.sslSocketFactory == that.sslSocketFactory &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.hostnameVerifier == that.hostnameVerifier &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.certificatePinner == that.certificatePinner &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.url.port == that.url.port</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>根据代码一个有用的连接需要满足以下几个条件：</p>
<ol>
<li>请求数没有达到上限，Http1 为 1，Http2 为 4。</li>
<li>连接还可以被使用，还没有关闭。</li>
<li>本次请求的端口号、支持协议、代理、代理选择器、连接规格(密钥算法套件 + TLS 版本)、主机名校验器等需要与连接的一致。注：<strong>使用同一个 OkHttpClient 进行请求也只有主机名和端口号会不同</strong>。</li>
<li>本次请求的主机名与连接的目标主机名一致。</li>
</ol>
<p>对于 Http1 连接必须同时满足上述 4 个条件才能进行复用，对于 Http2 主机名可以不同，但是需要额外满足以下几个条件：</p>
<ol>
<li>本次请求的所有路由中包括该连接的路由(有相同的 IP 地址和端口号)。</li>
<li>该连接上次请求是 Https 请求，并且当前请求的主机名必须在上次请求的服务端证书中。</li>
<li>通过 CertificatePinner 校验。</li>
</ol>
<p>下面继续分析 RealConnectionPool.findConnection 的剩余代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findConnection</span><span class="params">(...)</span></span>: RealConnection &#123;</span><br><span class="line">    ... 前面已分析</span><br><span class="line">    <span class="keyword">val</span> routes: List&lt;Route&gt;?</span><br><span class="line">    <span class="keyword">val</span> route: Route</span><br><span class="line">    <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) &#123;</span><br><span class="line">        routes = <span class="literal">null</span></span><br><span class="line">        route = nextRouteToTry!!</span><br><span class="line">        nextRouteToTry = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (routeSelection != <span class="literal">null</span> &amp;&amp; routeSelection!!.hasNext()) &#123;</span><br><span class="line">        routes = <span class="literal">null</span></span><br><span class="line">        route = routeSelection!!.next()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> localRouteSelector = routeSelector</span><br><span class="line">        <span class="keyword">if</span> (localRouteSelector == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建 RouteSelector</span></span><br><span class="line">            localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)</span><br><span class="line">            <span class="keyword">this</span>.routeSelector = localRouteSelector</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 RouteSelector 中获取 RouteSelection</span></span><br><span class="line">        <span class="keyword">val</span> localRouteSelection = localRouteSelector.next()</span><br><span class="line">        routeSelection = localRouteSelection</span><br><span class="line">        routes = localRouteSelection.routes</span><br><span class="line">        <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">        <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">            eventListener.connectionAcquired(call, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        route = localRouteSelection.next()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取不到连接，那么自己创建一个连接</span></span><br><span class="line">    <span class="keyword">val</span> newConnection = RealConnection(connectionPool, route)</span><br><span class="line">    call.connectionToCancel = newConnection</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 与目标服务端进行连接</span></span><br><span class="line">        newConnection.connect(</span><br><span class="line">            connectTimeout,</span><br><span class="line">            readTimeout,</span><br><span class="line">            writeTimeout,</span><br><span class="line">            pingIntervalMillis,</span><br><span class="line">            connectionRetryEnabled,</span><br><span class="line">            call,</span><br><span class="line">            eventListener</span><br><span class="line">        )</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        call.connectionToCancel = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将成功连接的路由进行记录（只是个内存缓存）</span></span><br><span class="line">    call.client.routeDatabase.connected(newConnection.route())</span><br><span class="line">    <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">        nextRouteToTry = route</span><br><span class="line">        newConnection.socket().closeQuietly()</span><br><span class="line">        eventListener.connectionAcquired(call, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新建的连接放入到连接池中</span></span><br><span class="line">    synchronized(newConnection) &#123;</span><br><span class="line">        connectionPool.put(newConnection)</span><br><span class="line">        call.acquireConnectionNoEvents(newConnection)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回调 eventListener.connectionAcquired</span></span><br><span class="line">    eventListener.connectionAcquired(call, newConnection)</span><br><span class="line">    <span class="keyword">return</span> newConnection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首次进入时 <code>nextRouteToTry</code>、<code>routeSelection</code> 都为 false，因此首先会去创建 <code>RouteSelector</code> 实例，然后从中获取到 <code>RouteSelection</code> 实例，再从中获取到路由列表。然后再次执行 <code>callAcquirePooledConnection</code> 传入路由列表获取连接，如果还是获取不到自己创建一个 <code>RealConnection</code> 并进行连接，连接成功后再次执行 <code>callAcquirePooledConnection</code> 获取连接，目的是尽量少的维护连接，假设 A、B 两个 Http2 请求同时发送，且这两个请求目标主机名端口号都一样，A 先创建了连接，将连接放入了连接池，B 也创建了连接，这时候从连接池获取到了 A 创建的连接，那么就会抛弃 B 自己创建的连接，并将当前成功连接的路由赋值给 <code>nextRouteTry</code>，方便下次重试使用。如果获取不到，将本次创建的连接放入连接池然后返回。</p>
<p>三次调用 <code>callAcquirePooledConnection</code> 的目的是：</p>
<ol>
<li>获取 Http1 连接</li>
<li>获取 Http1、Http2 连接</li>
<li>获取 Http2 连接</li>
</ol>
<p><strong>看到这里，应该还存在以下两个问题</strong>：</p>
<ol>
<li><strong>RouteSelector、RouteSelector.Selection、Route 这三者之间是什么关系，都是做什么用的？</strong></li>
<li><strong>RealConnection 是如何与目标服务器建立 TCP 连接，并进行握手？</strong></li>
</ol>
<p>首先分析第一个问题：</p>
<p>RouteSelector 构造器会调用 <code>resetNextProxy</code> 用来初始化代理列表</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RouteSelector.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">resetNextProxy</span><span class="params">(url: <span class="type">HttpUrl</span>, proxy: <span class="type">Proxy</span>?)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">selectProxies</span><span class="params">()</span></span>: List&lt;Proxy&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (proxy != <span class="literal">null</span>) <span class="keyword">return</span> listOf(proxy)</span><br><span class="line">        <span class="keyword">val</span> uri = url.toUri()</span><br><span class="line">        <span class="keyword">if</span> (uri.host == <span class="literal">null</span>) <span class="keyword">return</span> immutableListOf(Proxy.NO_PROXY)</span><br><span class="line">        <span class="keyword">val</span> proxiesOrNull = address.proxySelector.select(uri)</span><br><span class="line">        <span class="keyword">if</span> (proxiesOrNull.isNullOrEmpty()) <span class="keyword">return</span> immutableListOf(Proxy.NO_PROXY)</span><br><span class="line">        <span class="keyword">return</span> proxiesOrNull.toImmutableList()</span><br><span class="line">    &#125;</span><br><span class="line">    eventListener.proxySelectStart(call, url)</span><br><span class="line">    proxies = selectProxies()</span><br><span class="line">    nextProxyIndex = <span class="number">0</span></span><br><span class="line">    eventListener.proxySelectEnd(call, url, proxies)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有设置 <code>Proxy</code>，那么所有的代理由 <code>ProxySelector</code> 决定。其默认实现为 <code>DefaultProxySelector</code> ，如果没有为系统设置代理，那么返回一个类型为直连的 <code>Proxy</code> 实例，否则返回配置的系统代理。</p>
<p><strong>这里又提出两个疑问</strong></p>
<ol>
<li><strong>系统代理是在哪设置的？</strong></li>
<li><strong>如何才能绕过代理？</strong></li>
</ol>
<p>对于第一个疑问，应用程序进程启动后，就会通过反射调用 <code>ActivityThread.main</code> 方法，而在该方法中又会调用 <code>attach</code> 方法进而跨进程调用 <code>ActivityManagerService.attachApplication</code> 而在其内部又会跨进度调用 <code>bindApplication</code> 以及 <code>scheduleLaunchActivity</code>，这两个方法都只是发送了一个消息就返回了，等到 <code>ActivityManagerService</code> 执行完毕后，客户端进程执行到 <code>Looper.loop</code> 后，就开始执行第一个消息调用 <code>handleBindApplication</code> 方法，内部有如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ActivityThread.java</span></span><br><span class="line"><span class="keyword">final</span> IConnectivityManager service = IConnectivityManager.Stub.asInterface(b);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Proxy.setHttpProxySystemProperty(service.getProxyForNetwork(<span class="keyword">null</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>getProxyForNetwork</code> 中系统会读取网络配置中的代理设置，这个就不展开了。直接看一看 <code>setHttpProxySystemProperty</code> 方法时如何设置代理的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Proxy.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setHttpProxySystemProperty</span><span class="params">(ProxyInfo p)</span> </span>&#123;</span><br><span class="line">    String host = <span class="keyword">null</span>;</span><br><span class="line">    String port = <span class="keyword">null</span>;</span><br><span class="line">    String exclList = <span class="keyword">null</span>;</span><br><span class="line">    Uri pacFileUrl = Uri.EMPTY;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        host = p.getHost();</span><br><span class="line">        port = Integer.toString(p.getPort());</span><br><span class="line">        exclList = p.getExclusionListAsString();</span><br><span class="line">        pacFileUrl = p.getPacFileUrl();</span><br><span class="line">    &#125;</span><br><span class="line">    setHttpProxySystemProperty(host, port, exclList, pacFileUrl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setHttpProxySystemProperty</span><span class="params">(String host, String port, String exclList,</span></span></span><br><span class="line"><span class="function"><span class="params">            Uri pacFileUrl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exclList != <span class="keyword">null</span>) exclList = exclList.replace(<span class="string">","</span>, <span class="string">"|"</span>);</span><br><span class="line">    <span class="keyword">if</span> (host != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.setProperty(<span class="string">"http.proxyHost"</span>, host);</span><br><span class="line">        System.setProperty(<span class="string">"https.proxyHost"</span>, host);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.clearProperty(<span class="string">"http.proxyHost"</span>);</span><br><span class="line">        System.clearProperty(<span class="string">"https.proxyHost"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (port != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.setProperty(<span class="string">"http.proxyPort"</span>, port);</span><br><span class="line">        System.setProperty(<span class="string">"https.proxyPort"</span>, port);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.clearProperty(<span class="string">"http.proxyPort"</span>);</span><br><span class="line">        System.clearProperty(<span class="string">"https.proxyPort"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exclList != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.setProperty(<span class="string">"http.nonProxyHosts"</span>, exclList);</span><br><span class="line">        System.setProperty(<span class="string">"https.nonProxyHosts"</span>, exclList);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.clearProperty(<span class="string">"http.nonProxyHosts"</span>);</span><br><span class="line">        System.clearProperty(<span class="string">"https.nonProxyHosts"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!Uri.EMPTY.equals(pacFileUrl)) &#123;</span><br><span class="line">        ProxySelector.setDefault(<span class="keyword">new</span> PacProxySelector());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ProxySelector.setDefault(sDefaultProxySelector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部逻辑非常简单，解析代理信息，设置或清除以下六个系统属性：</p>
<ol>
<li>http.proxyHost     http请求代理主机</li>
<li>https.proxyHost   https请求代理主机</li>
<li>http.proxyPort      http请求代理端口</li>
<li>https.proxyPort    https请求代理端口</li>
<li>http.nonProxyHosts http请求不进行代理的主机列表 </li>
<li>https.nonProxyHosts https请求不进行代理的主机列表</li>
</ol>
<p>如果存在 PAC 脚本那么设置默认代理选择为 <code>PacProxySelector</code>，如果不存在那么设置  <code>DefaultProxySelector</code> 注：PAC 脚本其实就是一段 JS，指定 URL 对应的代理。</p>
<p>默认代理选择器会读取上述几个参数，如果能找到就组装成一个 <code>Proxy</code> 实例返回，如果找不到那么返回 <code>Proxy.NO_PROXY</code>。至此第一个疑问解决了，再来看看如何绕过代理。其实绕过代理很简单，只需要为 <code>OkHttpClient</code> 设置 <code>Proxy</code> ，代码如下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder()</span><br><span class="line">    .proxy(Proxy.NO_PROXY)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<p>继续回到 <code>RouteSelector</code>，通过调用其 <code>next</code> 方法获取到 <code>RouteSelection</code> 实例，看看具体实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RouteSelector.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: Selection &#123;</span><br><span class="line">    <span class="keyword">val</span> routes = mutableListOf&lt;Route&gt;()</span><br><span class="line">    <span class="keyword">while</span> (hasNextProxy()) &#123;</span><br><span class="line">        <span class="keyword">val</span> proxy = nextProxy()</span><br><span class="line">        <span class="keyword">for</span> (inetSocketAddress <span class="keyword">in</span> inetSocketAddresses) &#123;</span><br><span class="line">            <span class="keyword">val</span> route = Route(address, proxy, inetSocketAddress)</span><br><span class="line">            <span class="keyword">if</span> (routeDatabase.shouldPostpone(route)) &#123;</span><br><span class="line">                postponedRoutes += route</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                routes += route</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (routes.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (routes.isEmpty()) &#123;</span><br><span class="line">        routes += postponedRoutes</span><br><span class="line">        postponedRoutes.clear()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Selection(routes)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">nextProxy</span><span class="params">()</span></span>: Proxy &#123;</span><br><span class="line">    <span class="keyword">val</span> result = proxies[nextProxyIndex++]</span><br><span class="line">    resetNextInetSocketAddress(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">resetNextInetSocketAddress</span><span class="params">(proxy: <span class="type">Proxy</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mutableInetSocketAddresses = mutableListOf&lt;InetSocketAddress&gt;()</span><br><span class="line">    inetSocketAddresses = mutableInetSocketAddresses</span><br><span class="line">    <span class="keyword">val</span> socketHost: String</span><br><span class="line">    <span class="keyword">val</span> socketPort: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">if</span> (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) &#123;</span><br><span class="line">        socketHost = address.url.host</span><br><span class="line">        socketPort = address.url.port</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> proxyAddress = proxy.address()</span><br><span class="line">        socketHost = proxyAddress.socketHost</span><br><span class="line">        socketPort = proxyAddress.port</span><br><span class="line">    &#125;</span><br><span class="line">    eventListener.dnsStart(call, socketHost)</span><br><span class="line">    <span class="keyword">val</span> addresses = address.dns.lookup(socketHost)</span><br><span class="line">    <span class="keyword">if</span> (addresses.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> UnknownHostException(<span class="string">"<span class="subst">$&#123;address.dns&#125;</span> returned no addresses for <span class="variable">$socketHost</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    eventListener.dnsEnd(call, socketHost, addresses)</span><br><span class="line">    <span class="keyword">for</span> (inetAddress <span class="keyword">in</span> addresses) &#123;</span><br><span class="line">        mutableInetSocketAddresses += InetSocketAddress(inetAddress, socketPort)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部首先会获取当前索引处的代理，然后访问 DNS 服务器获取该代理地址对应的 IP 地址列表，并将其放入 <code>inetSocketAddresses</code> 成员变量中，接着为每一个 <code>inetSocketAddress</code> 创建一个 <code>Route</code> 实例，如果该路由已经在数据库的失败路由中，那么将其放入 <code>postponedRoutes</code> 列表中，否则将其放入 <code>routes</code> 列表中。当该代理的所有路由都处理完毕后，将 <code>postponedRoutes</code> 拼接到 <code>routes</code> 后面，然后构建一个  <code>Selection</code> 实例然后。</p>
<p>到这里为止 <code>RouteSelector</code>、<code>RouteSelector.Selection</code>、<code>Route</code> 这三者的作用已经很明了，</p>
<p><code>RouteSelector</code> 获取目标地址的所有代理，并将每个代理所对应的路由以 <code>Selection</code> 的形式返回。</p>
<figure class="highlight plain"><figcaption><span>维护了一个代理下所有的路由信息。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;Route&#96;&#96;&#96; 单个路由，包括目标 IP 地址及端口号。</span><br><span class="line"></span><br><span class="line">接着看看第二个问题，到底 &#96;RealConnection&#96; 是如何建立连接的。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;kotlin</span><br><span class="line">fun connect(...) &#123;</span><br><span class="line">    var routeException: RouteException? &#x3D; null</span><br><span class="line">    val connectionSpecs &#x3D; route.address.connectionSpecs</span><br><span class="line">    val connectionSpecSelector &#x3D; ConnectionSpecSelector(connectionSpecs)</span><br><span class="line">    if (route.address.sslSocketFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (ConnectionSpec.CLEARTEXT !in connectionSpecs) &#123;</span><br><span class="line">            throw RouteException(UnknownServiceException(</span><br><span class="line">                &quot;CLEARTEXT communication not enabled for client&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">        val host &#x3D; route.address.url.host</span><br><span class="line">        if (!Platform.get().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">            throw RouteException(UnknownServiceException(</span><br><span class="line">                &quot;CLEARTEXT communication to $host not permitted by network security policy&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) &#123;</span><br><span class="line">            throw RouteException(UnknownServiceException(</span><br><span class="line">                &quot;H2_PRIOR_KNOWLEDGE cannot be used with HTTPS&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (route.requiresTunnel()) &#123;</span><br><span class="line">                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)</span><br><span class="line">                if (rawSocket &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">            &#125;</span><br><span class="line">            establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</span><br><span class="line">            eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)</span><br><span class="line">            break</span><br><span class="line">        &#125; catch (e: IOException) &#123;</span><br><span class="line">            ...</span><br><span class="line">            eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)</span><br><span class="line">            if (routeException &#x3D;&#x3D; null) &#123;</span><br><span class="line">                routeException &#x3D; RouteException(e)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                routeException.addConnectException(e)</span><br><span class="line">            &#125;</span><br><span class="line">            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123;</span><br><span class="line">                throw routeException</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (route.requiresTunnel() &amp;&amp; rawSocket &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw RouteException(ProtocolException(</span><br><span class="line">            &quot;Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS&quot;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断是否是 Http 请求（虽然 <code>OkHttpClient</code> 中 <code>sslSocketFactory</code> 不做特殊配置一定不为空，但是如果是 Http 请求 <code>Address</code> 中的 <code>sslSocketFactory</code> 就为空）</p>
<ol>
<li>如果是 Http 请求，并且明文传输规格不在连接规格列表中或者应用不允许明文传输则抛出异常。</li>
<li>如果是 Https 请求，并且支持的协议列表中含有 <code>Protocol.H2_PRIOR_KNOWLEDGE</code> （表示预先知道服务端支持明文 Http2 协议）则抛出异常。</li>
</ol>
<p>接着判断是否需要建立 HTTP TUNNEL，如果配置了 HTTP 代理同时该请求又是 HTTPS 请求，那么调用 <code>connectTunnel</code> 在连接后与代理服务器建立 <code>Tunnel</code>，否则执行 <code>connectSocket</code> 进行连接。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">connectTunnel</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tunnelRequest: Request = createTunnelRequest()</span><br><span class="line">    <span class="keyword">val</span> url = tunnelRequest.url</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until MAX_TUNNEL_ATTEMPTS) &#123;</span><br><span class="line">        connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">        tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url)</span><br><span class="line">        ?: <span class="keyword">break</span></span><br><span class="line">        rawSocket?.closeQuietly()</span><br><span class="line">        rawSocket = <span class="literal">null</span></span><br><span class="line">        sink = <span class="literal">null</span></span><br><span class="line">        source = <span class="literal">null</span></span><br><span class="line">        eventListener.connectEnd(call, route.socketAddress, route.proxy, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createTunnelRequest</span><span class="params">()</span></span>: Request &#123;</span><br><span class="line">    <span class="keyword">val</span> proxyConnectRequest = Request.Builder()</span><br><span class="line">        .url(route.address.url)</span><br><span class="line">        .method(<span class="string">"CONNECT"</span>, <span class="literal">null</span>)</span><br><span class="line">        .header(<span class="string">"Host"</span>, route.address.url.toHostHeader(includeDefaultPort = <span class="literal">true</span>))</span><br><span class="line">        .header(<span class="string">"Proxy-Connection"</span>, <span class="string">"Keep-Alive"</span>) <span class="comment">// For HTTP/1.0 proxies like Squid.</span></span><br><span class="line">        .header(<span class="string">"User-Agent"</span>, userAgent)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> fakeAuthChallengeResponse = Response.Builder()</span><br><span class="line">        .request(proxyConnectRequest)</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(HTTP_PROXY_AUTH)</span><br><span class="line">        .message(<span class="string">"Preemptive Authenticate"</span>)</span><br><span class="line">        .body(EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">        .receivedResponseAtMillis(-<span class="number">1L</span>)</span><br><span class="line">        .header(<span class="string">"Proxy-Authenticate"</span>, <span class="string">"OkHttp-Preemptive"</span>)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> authenticatedRequest = route.address.proxyAuthenticator</span><br><span class="line">    	.authenticate(route, fakeAuthChallengeResponse)</span><br><span class="line">    <span class="keyword">return</span> authenticatedRequest ?: proxyConnectRequest</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">connectSocket</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> proxy = route.proxy</span><br><span class="line">    <span class="keyword">val</span> address = route.address</span><br><span class="line">    <span class="keyword">val</span> rawSocket = <span class="keyword">when</span> (proxy.type()) &#123;</span><br><span class="line">        Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!!</span><br><span class="line">        <span class="keyword">else</span> -&gt; Socket(proxy)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.rawSocket = rawSocket</span><br><span class="line">    eventListener.connectStart(call, route.socketAddress, proxy)</span><br><span class="line">    rawSocket.soTimeout = readTimeout</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Platform.<span class="keyword">get</span>().connectSocket(rawSocket, route.socketAddress, connectTimeout)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: ConnectException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ConnectException(<span class="string">"Failed to connect to <span class="subst">$&#123;route.socketAddress&#125;</span>"</span>).apply &#123;</span><br><span class="line">            initCause(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source = rawSocket.source().buffer()</span><br><span class="line">    sink = rawSocket.sink().buffer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建请求（建立隧道）。</li>
<li>伪造响应，强制从 <code>ProxyAuthenticator</code> 中获取带认证信息的请求。</li>
<li>通过 <code>SocketFactory</code> 创建 <code>Socket</code>，并执行连接，然后创建 <code>source</code>、<code>sink</code> 分别对应输入、输出流。</li>
<li>发送建立隧道请求。</li>
<li>服务端返回 407 ，表示未认证，从 <code>ProxyAuthenticator</code> 中再次获取后重新发送请求。</li>
<li>如果返回 200，那么表示建立完成，具体的就不展开了。</li>
</ol>
<p>连接已经建立完毕，接着调用 <code>establishProtocol</code> 进行协议的处理。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">establishProtocol</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (route.address.sslSocketFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Protocol.H2_PRIOR_KNOWLEDGE <span class="keyword">in</span> route.address.protocols) &#123;</span><br><span class="line">            socket = rawSocket</span><br><span class="line">            protocol = Protocol.H2_PRIOR_KNOWLEDGE</span><br><span class="line">            startHttp2(pingIntervalMillis)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        socket = rawSocket</span><br><span class="line">        protocol = Protocol.HTTP_1_1</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    eventListener.secureConnectStart(call)</span><br><span class="line">    connectTls(connectionSpecSelector)</span><br><span class="line">    eventListener.secureConnectEnd(call, handshake)</span><br><span class="line">    <span class="keyword">if</span> (protocol === Protocol.HTTP_2) &#123;</span><br><span class="line">        startHttp2(pingIntervalMillis)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果进行明文传输并且协议为 Http2，那么执行 <code>startHttp2</code> 启动。</p>
<p>如果不进行明文传输执行 <code>connectTls</code> 进行握手，如果协议是 Http2 接着执行 <code>startHttp2</code> 启动。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startHttp2</span><span class="params">(pingIntervalMillis: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> socket = <span class="keyword">this</span>.socket!!</span><br><span class="line">    <span class="keyword">val</span> source = <span class="keyword">this</span>.source!!</span><br><span class="line">    <span class="keyword">val</span> sink = <span class="keyword">this</span>.sink!!</span><br><span class="line">    socket.soTimeout = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> http2Connection = Http2Connection.Builder(client = <span class="literal">true</span>, taskRunner = TaskRunner.INSTANCE)</span><br><span class="line">    .socket(socket, route.address.url.host, source, sink)</span><br><span class="line">    .listener(<span class="keyword">this</span>)</span><br><span class="line">    .pingIntervalMillis(pingIntervalMillis)</span><br><span class="line">    .build()</span><br><span class="line">    <span class="keyword">this</span>.http2Connection = http2Connection</span><br><span class="line">    <span class="keyword">this</span>.allocationLimit = Http2Connection.DEFAULT_SETTINGS.getMaxConcurrentStreams()</span><br><span class="line">    http2Connection.start()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">(sendConnectionPreface: <span class="type">Boolean</span> = <span class="literal">true</span>, taskRunner: <span class="type">TaskRunner</span> = TaskRunner.INSTANCE)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sendConnectionPreface) &#123;</span><br><span class="line">        writer.connectionPreface()</span><br><span class="line">        writer.settings(okHttpSettings)</span><br><span class="line">        <span class="keyword">val</span> windowSize = okHttpSettings.initialWindowSize</span><br><span class="line">        <span class="keyword">if</span> (windowSize != DEFAULT_INITIAL_WINDOW_SIZE) &#123;</span><br><span class="line">            writer.windowUpdate(<span class="number">0</span>, (windowSize - DEFAULT_INITIAL_WINDOW_SIZE).toLong())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    taskRunner.newQueue().execute(name = connectionName, block = readerRunnable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致上就是发送了 <code>connectionPreface</code> 以及 <code>setting</code> ，<strong>至于更详细的有待后续理解了 Http2 原理后再来补充</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">connectTls</span><span class="params">(connectionSpecSelector: <span class="type">ConnectionSpecSelector</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> address = route.address</span><br><span class="line">    <span class="keyword">val</span> sslSocketFactory = address.sslSocketFactory</span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> sslSocket: SSLSocket? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sslSocket = sslSocketFactory!!.createSocket(</span><br><span class="line">            rawSocket, address.url.host, address.url.port, <span class="literal">true</span> <span class="comment">/* autoClose */</span>) <span class="keyword">as</span> SSLSocket</span><br><span class="line">        <span class="keyword">val</span> connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket)</span><br><span class="line">        <span class="keyword">if</span> (connectionSpec.supportsTlsExtensions) &#123;</span><br><span class="line">            Platform.<span class="keyword">get</span>().configureTlsExtensions(sslSocket, address.url.host, address.protocols)</span><br><span class="line">        &#125;</span><br><span class="line">        sslSocket.startHandshake()</span><br><span class="line">        <span class="keyword">val</span> sslSocketSession = sslSocket.session</span><br><span class="line">        <span class="keyword">val</span> unverifiedHandshake = sslSocketSession.handshake()</span><br><span class="line">        <span class="keyword">if</span> (!address.hostnameVerifier!!.verify(address.url.host, sslSocketSession)) &#123;</span><br><span class="line">            <span class="keyword">val</span> peerCertificates = unverifiedHandshake.peerCertificates</span><br><span class="line">            <span class="keyword">if</span> (peerCertificates.isNotEmpty()) &#123;</span><br><span class="line">                <span class="keyword">val</span> cert = peerCertificates[<span class="number">0</span>] <span class="keyword">as</span> X509Certificate</span><br><span class="line">                <span class="keyword">throw</span> SSLPeerUnverifiedException(<span class="string">"""</span></span><br><span class="line"><span class="string">              |Hostname <span class="subst">$&#123;address.url.host&#125;</span> not verified:</span></span><br><span class="line"><span class="string">              |    certificate: <span class="subst">$&#123;CertificatePinner.pin(cert)&#125;</span></span></span><br><span class="line"><span class="string">              |    DN: <span class="subst">$&#123;cert.subjectDN.name&#125;</span></span></span><br><span class="line"><span class="string">              |    subjectAltNames: <span class="subst">$&#123;OkHostnameVerifier.allSubjectAltNames(cert)&#125;</span></span></span><br><span class="line"><span class="string">              """</span>.trimMargin())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> SSLPeerUnverifiedException(</span><br><span class="line">                    <span class="string">"Hostname <span class="subst">$&#123;address.url.host&#125;</span> not verified (no certificates)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> certificatePinner = address.certificatePinner!!</span><br><span class="line">        handshake = Handshake(unverifiedHandshake.tlsVersion, unverifiedHandshake.cipherSuite,</span><br><span class="line">                              unverifiedHandshake.localCertificates) &#123;</span><br><span class="line">            certificatePinner.certificateChainCleaner!!.clean(unverifiedHandshake.peerCertificates,</span><br><span class="line">                                                              address.url.host)</span><br><span class="line">        &#125;</span><br><span class="line">        certificatePinner.check(address.url.host) &#123;</span><br><span class="line">            handshake!!.peerCertificates.map &#123; it <span class="keyword">as</span> X509Certificate &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> maybeProtocol = <span class="keyword">if</span> (connectionSpec.supportsTlsExtensions) &#123;</span><br><span class="line">            Platform.<span class="keyword">get</span>().getSelectedProtocol(sslSocket)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        socket = sslSocket</span><br><span class="line">        source = sslSocket.source().buffer()</span><br><span class="line">        sink = sslSocket.sink().buffer()</span><br><span class="line">        protocol = <span class="keyword">if</span> (maybeProtocol != <span class="literal">null</span>) Protocol.<span class="keyword">get</span>(maybeProtocol) <span class="keyword">else</span> Protocol.HTTP_1_1</span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sslSocket != <span class="literal">null</span>) &#123;</span><br><span class="line">            Platform.<span class="keyword">get</span>().afterHandshake(sslSocket)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            sslSocket?.closeQuietly()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建 SSLSocket。</li>
<li>获取 ConnectionSpec。</li>
<li>配置 TLS 扩展信息。</li>
<li>进行握手这个过程会校验证书的合法性，但是没校验证书是否是本次请求期望的。</li>
<li>验证当前请求主机名是否在服务器证书备用名称列表中（Subject Alternative Name）。</li>
</ol>
<h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>接着再看看 CallServerInterceptor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallServerInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> forWebSocket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallServerInterceptor</span><span class="params">(<span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Exchange exchange = realChain.exchange();</span><br><span class="line">        <span class="comment">// 根据Request生成对应的字节数组并且写入到Buffer中</span></span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">        exchange.writeRequestHeaders(request);</span><br><span class="line">        <span class="keyword">boolean</span> responseHeadersStarted = <span class="keyword">false</span>;</span><br><span class="line">        Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果请求包含请求体，写入请求体</span></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">                exchange.flushRequest();</span><br><span class="line">                responseHeadersStarted = <span class="keyword">true</span>;</span><br><span class="line">                exchange.responseHeadersStart();</span><br><span class="line">                responseBuilder = exchange.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.body().isDuplex()) &#123;</span><br><span class="line">                    exchange.flushRequest();</span><br><span class="line">                    BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                            exchange.createRequestBody(request, <span class="keyword">true</span>));</span><br><span class="line">                    request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                            exchange.createRequestBody(request, <span class="keyword">false</span>));</span><br><span class="line">                    request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                    bufferedRequestBody.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                exchange.noRequestBody();</span><br><span class="line">                <span class="keyword">if</span> (!exchange.connection().isMultiplexed()) &#123;</span><br><span class="line">                    exchange.noNewExchangesOnConnection();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exchange.noRequestBody();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (request.body() == <span class="keyword">null</span> || !request.body().isDuplex()) &#123;</span><br><span class="line">            <span class="comment">// 将Buffer中的数据写给服务端</span></span><br><span class="line">            exchange.finishRequest();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">            exchange.responseHeadersStart();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取响应头</span></span><br><span class="line">            responseBuilder = exchange.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Response response = responseBuilder</span><br><span class="line">                .request(request)</span><br><span class="line">                .handshake(exchange.connection().handshake())</span><br><span class="line">                .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">int</span> code = response.code();</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">            response = exchange.readResponseHeaders(<span class="keyword">false</span>)</span><br><span class="line">                    .request(request)</span><br><span class="line">                    .handshake(exchange.connection().handshake())</span><br><span class="line">                    .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            code = response.code();</span><br><span class="line">        &#125;</span><br><span class="line">        exchange.responseHeadersEnd(response);</span><br><span class="line">        <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(exchange.openResponseBody(response))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">                || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">            exchange.noNewExchangesOnConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">                    <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CallServerInterceptor 真正的进行了网络请求，会根据 Request 实例构建出 Http 请求，获取到 Http 响应后再构建出 HttpResponse，网络请求成功后会接着执行前几个 Interceptor 的剩余代码，这里就不看了。直接回到RealCall.execute。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.timeoutEnter();</span><br><span class="line">    transmitter.callStart();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> getResponseWithInterceptorChain();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    finished(runningSyncCalls, call);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">        idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> isRunning = promoteAndExecute();</span><br><span class="line">    <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出当一次同步请求结束后，会将 RealCall 中队列中移除，然后启动正在等待的异步请求，如果没有异步请求会回调 IdleCallback 。接着看看异步请求过程。</p>
<h2 id="Call-enqueue"><a href="#Call-enqueue" class="headerlink" title="Call.enqueue"></a>Call.enqueue</h2><p>enqueue 方法用于执行异步请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.callStart();</span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里都和 execute 一样只是最后调用了 Dispatcher 的 enqueue 方法，不过传入的是 AsyncCall 实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 将call加入到准备队列中去</span></span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">        <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">            <span class="comment">// 刚刚创建的call不是使用webSocket所以进入这里</span></span><br><span class="line">            AsyncCall existingCall = findExistingCallWithHost(call.host());</span><br><span class="line">            <span class="comment">// 目的只是为了统计每个Host有几个AsyncCall</span></span><br><span class="line">            <span class="keyword">if</span> (existingCall != <span class="keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从正在执行或者等待执行的call队列中取出host属性为host的AsyncCall实例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AsyncCall <span class="title">findExistingCallWithHost</span><span class="params">(String host)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (AsyncCall existingCall : runningAsyncCalls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (existingCall.host().equals(host)) <span class="keyword">return</span> existingCall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (AsyncCall existingCall : readyAsyncCalls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (existingCall.host().equals(host)) <span class="keyword">return</span> existingCall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            AsyncCall asyncCall = i.next();</span><br><span class="line">            <span class="comment">// 如果已经达到最大请求数64就停止执行</span></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">            <span class="comment">// 如果每个Host达到了最大请求数5个就跳过该call</span></span><br><span class="line">            <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line">            i.remove();</span><br><span class="line">            <span class="comment">// 每个端口请求计数加1</span></span><br><span class="line">            asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">            executableCalls.add(asyncCall);</span><br><span class="line">            runningAsyncCalls.add(asyncCall);</span><br><span class="line">        &#125;</span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">        AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">        <span class="comment">// 创建一个线程池，然后执行AsyncCall的execute方法</span></span><br><span class="line">        asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">executeOn</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                client.dispatcher().finished(<span class="keyword">this</span>); <span class="comment">// This call is no longer running!</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在线程池中执行</span></span><br><span class="line">        <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">        transmitter.timeoutEnter();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Response response = getResponseWithInterceptorChain();</span><br><span class="line">            signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">            responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 端口请求计数减1</span></span><br><span class="line">            client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用了 enqueue 发送网络请求，那么最终会在线程池中执行 AsyncCall 的 execute 方法，其内部实现与同步执行基本类似，注意最后会在子线程中直接调用 onResponse ，因此我们不能在 onResponse 里面直接更新 UI 。我们可以写一个 WrapCall 将 Call 进行包装这样就能实现回调在主线程了，代码如下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrapCall</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> call: Call) : Call <span class="keyword">by</span> call &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">        call.enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">                handler.post &#123;</span><br><span class="line">                    responseCallback.onFailure(call, e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">                handler.post &#123;</span><br><span class="line">                    responseCallback.onResponse(call, response)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证 handler 只会创建一次</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> handler = Handler(Looper.getMainLooper())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外界使用，只要包装下</span></span><br><span class="line"><span class="keyword">val</span> call = WrapCall(client.newCall(request))</span><br></pre></td></tr></table></figure>

<p>源码分析到这网络流程基本已经清晰，下面再来看看 OkHttp 的连接复用。</p>
<h2 id="ConnectionPoll"><a href="#ConnectionPoll" class="headerlink" title="ConnectionPoll"></a>ConnectionPoll</h2><p>首先需要连接复用需要设置请求头 Connection: Keep-Alive ，这个已经在 BridgeInterceptor 里面设置了，当然如果响应头 Connection: false ，那么连接还是不能复用，连接池的具体实现是 RealConnectionPool ，每次在 ConnectInterceptor 的 intercepte 方法都会尝试着先从连接池中取出一个连接，取不到满足条件的才会新建一个连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealConnectionPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个线程池是专门用来执行清理线程的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span> <span class="comment">/* corePoolSize */</span>,</span><br><span class="line">            Integer.MAX_VALUE <span class="comment">/* maximumPoolSize */</span>, <span class="number">60L</span> <span class="comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">"OkHttp ConnectionPool"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">// 最大空闲连接数 默认5个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxIdleConnections;</span><br><span class="line">    <span class="comment">// 最大保存存活的空闲连接时间 默认5分钟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> keepAliveDurationNs;</span><br><span class="line">    <span class="comment">// 当向连接池中加入一个连接后会执行清理操作，内部会寻找空闲时间最长的连接，如果其空闲时间</span></span><br><span class="line">    <span class="comment">// 已经超过了最长时间就会将其关闭，不然就等待指定时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">            <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">                waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (RealConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        RealConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 双端队列保存当前OkHttpClient的所有连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录了失败的路由</span></span><br><span class="line">    <span class="keyword">final</span> RouteDatabase routeDatabase = <span class="keyword">new</span> RouteDatabase();</span><br><span class="line">    <span class="comment">// 清理线程是否正在执行</span></span><br><span class="line">    <span class="keyword">boolean</span> cleanupRunning;</span><br><span class="line">    <span class="comment">// 首先创建了一个最大空闲连接为5，最大保存存活时间5分钟的连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealConnectionPool</span><span class="params">(<span class="keyword">int</span> maxIdleConnections, <span class="keyword">long</span> keepAliveDuration, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxIdleConnections = maxIdleConnections;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);</span><br><span class="line">        <span class="keyword">if</span> (keepAliveDuration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"keepAliveDuration &lt;= 0: "</span> + keepAliveDuration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取空闲连接数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">idleConnectionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connection.transmitters.isEmpty()) total++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 总共的连接数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">connectionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connections.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Transmitter调用该方法获取连接，内部判断如果连接池有连接满足条件就返回true，不然返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">transmitterAcquirePooledConnection</span><span class="params">(Address address, Transmitter transmitter,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               @Nullable List&lt;Route&gt; routes, <span class="keyword">boolean</span> requireMultiplexed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requireMultiplexed &amp;&amp; !connection.isMultiplexed()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!connection.isEligible(address, routes)) <span class="keyword">continue</span>;</span><br><span class="line">            transmitter.acquireConnectionNoEvents(connection);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个新建的连接放入到连接池中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">        <span class="comment">// 如果清理线程还没运行就开始运行</span></span><br><span class="line">        <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">            cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">            executor.execute(cleanupRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再将连接放入双端队列中去</span></span><br><span class="line">        connections.add(connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当一个连接从执行中变成了空闲时调用，该方法会唤醒清理线程</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">connectionBecameIdle</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">if</span> (connection.noNewExchanges || maxIdleConnections == <span class="number">0</span>) &#123;</span><br><span class="line">            connections.remove(connection);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            notifyAll(); <span class="comment">// Awake the cleanup thread: we may have exceeded the idle connection limit.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭所有的连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;RealConnection&gt; evictedConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">                RealConnection connection = i.next();</span><br><span class="line">                <span class="keyword">if</span> (connection.transmitters.isEmpty()) &#123;</span><br><span class="line">                    connection.noNewExchanges = <span class="keyword">true</span>;</span><br><span class="line">                    evictedConnections.add(connection);</span><br><span class="line">                    i.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (RealConnection connection : evictedConnections) &#123;</span><br><span class="line">            closeQuietly(connection.socket());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果可以清理的话就关闭Socket返回0，不然返回需要等待的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">        RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">                RealConnection connection = i.next();</span><br><span class="line">                <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    inUseConnectionCount++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                idleConnectionCount++;</span><br><span class="line">                <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">                <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">                    longestIdleDurationNs = idleDurationNs;</span><br><span class="line">                    longestIdleConnection = connection;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">                    || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">                connections.remove(longestIdleConnection);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        closeQuietly(longestIdleConnection.socket());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pruneAndGetAllocationCount</span><span class="params">(RealConnection connection, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于Http1.1这个List最多也只有一个元素</span></span><br><span class="line">        List&lt;Reference&lt;Transmitter&gt;&gt; references = connection.transmitters;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; references.size(); ) &#123;</span><br><span class="line">            Reference&lt;Transmitter&gt; reference = references.get(i);</span><br><span class="line">            <span class="keyword">if</span> (reference.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发现一个泄露的transmitter，这是一个应用程序的bug</span></span><br><span class="line">            TransmitterReference transmitterRef = (TransmitterReference) reference;</span><br><span class="line">            String message = <span class="string">"A connection to "</span> + connection.route().address().url()</span><br><span class="line">                    + <span class="string">" was leaked. Did you forget to close a response body?"</span>;</span><br><span class="line">            Platform.get().logCloseableLeak(message, transmitterRef.callStackTrace);</span><br><span class="line">            references.remove(i);</span><br><span class="line">            connection.noNewExchanges = <span class="keyword">true</span>; eviction.</span><br><span class="line">            <span class="keyword">if</span> (references.isEmpty()) &#123;</span><br><span class="line">                connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> references.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接失败时调用将失败的Route放入到RouteDatabase中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectFailed</span><span class="params">(Route failedRoute, IOException failure)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Tell the proxy selector when we fail to connect on a fresh connection.</span></span><br><span class="line">        <span class="keyword">if</span> (failedRoute.proxy().type() != Proxy.Type.DIRECT) &#123;</span><br><span class="line">            Address address = failedRoute.address();</span><br><span class="line">            address.proxySelector().connectFailed(</span><br><span class="line">                    address.url().uri(), failedRoute.proxy().address(), failure);</span><br><span class="line">        &#125;</span><br><span class="line">        routeDatabase.failed(failedRoute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不管是同步请求还是异步请求都是通过 Dispatcher 类进行分发，然后经过从上到下5个 Interceptor 才能发起请求，获取到响应后还会经过这5个拦截器然后才将结果返回到外界，典型的责任链模式与 Android 事件分发差不多 。因此 OkHttp 核心就是 Dispatcher、Intercept。</p>
<p>Dispatcher:</p>
<p>内部维护了三个双端队列（同步请求队列、异步请求队列、异步准备队列）、一个线程池（同 CacheThreadPoll ）。</p>
<ol>
<li>执行同步调用时加入到同步请求队列，请求完毕后移除，然后看看异步准备队列是否为空，不为空就请求。</li>
<li>执行异步调用时判断是否达到最大请求数量，以及最大每个 Host 请求数量，如果都不满，那么加入异步请求队列，如果某个满了，那么加入异步准备队列，当执行完毕后异步准备队列是否为空，不为空就请求。</li>
</ol>
<p>Interceptor:</p>
<ol>
<li>RetryAndFollowUpInterceptor 用于错误重试，以及重定向。</li>
<li>BridgeInterceptor 用于添加请求头(User-Agent、Connection等等)，收到响应的时候可能会进行 GZip 解压。</li>
<li>CacheInterceptor 进行缓存管理，默认不带缓存，如果需要缓存可以给 OkHttpClient 设置 cache 属性，可以使用 OkHttp 内置的 Cache 类。</li>
<li>ConnectInterceptor 进行连接，首先从连接池中取出可以复用的连接，取不到就新建一个然后通过InetAddress 获取到域名对于的IP地址，然后创建 Socket 与服务端进行连接，连接成功后如果是Https请求还会进行握手验证证书操作。</li>
<li>CallServerInterceptor 用于真正的发起请求，从 Socket 获取的输出流写入请求数据，从输入流中读取到响应数据。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/15/EventBus%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="next" title="EventBus 源码分析">
                <i class="fa fa-chevron-left"></i> EventBus 源码分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/13/Retrofit%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="Retrofit 源码分析">
                Retrofit 源码分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="何富威" />
            
              <p class="site-author-name" itemprop="name">何富威</p>
              <p class="site-description motion-element" itemprop="description">行百里者半九十</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单使用"><span class="nav-number">2.</span> <span class="nav-text">简单使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OkHttpClient-实例的创建"><span class="nav-number">3.</span> <span class="nav-text">OkHttpClient 实例的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Request-实例的创建"><span class="nav-number">4.</span> <span class="nav-text">Request 实例的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Call-实例的创建"><span class="nav-number">5.</span> <span class="nav-text">Call 实例的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Call-execute-和-Call-enqueue"><span class="nav-number">6.</span> <span class="nav-text">Call.execute 和 Call.enqueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RetryAndFollowUpInterceptor"><span class="nav-number">6.1.</span> <span class="nav-text">RetryAndFollowUpInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BridgeInterceptor"><span class="nav-number">6.2.</span> <span class="nav-text">BridgeInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CacheInterceptor"><span class="nav-number">6.3.</span> <span class="nav-text">CacheInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConnectIntercept"><span class="nav-number">6.4.</span> <span class="nav-text">ConnectIntercept</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CallServerInterceptor"><span class="nav-number">6.5.</span> <span class="nav-text">CallServerInterceptor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Call-enqueue"><span class="nav-number">7.</span> <span class="nav-text">Call.enqueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConnectionPoll"><span class="nav-number">8.</span> <span class="nav-text">ConnectionPoll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">9.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">何富威</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
