<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="前言半年前阅读了 Volley 源码，但是现在主流网络请求都是使用 OkHttp + Retrofit + RxJava ，因此打算好好研究下 OkHttp 的源码(基于 OkHttp3.14.1)，记录一下。注：仓库地址">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp 源码分析">
<meta property="og:url" content="http://yoursite.com/2019/05/08/OkHttp%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="何富威的博客">
<meta property="og:description" content="前言半年前阅读了 Volley 源码，但是现在主流网络请求都是使用 OkHttp + Retrofit + RxJava ，因此打算好好研究下 OkHttp 的源码(基于 OkHttp3.14.1)，记录一下。注：仓库地址">
<meta property="article:published_time" content="2019-05-08T05:23:10.000Z">
<meta property="article:modified_time" content="2020-05-07T07:19:25.901Z">
<meta property="article:author" content="何富威">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/08/OkHttp 源码分析/"/>





  <title>OkHttp 源码分析 | 何富威的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8dd458e5cf03e833389caa5705955567";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">何富威的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-Android" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/08/OkHttp%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="何富威">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何富威的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OkHttp 源码分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-08T13:23:10+08:00">
                2019-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>半年前阅读了 Volley 源码，但是现在主流网络请求都是使用 OkHttp + Retrofit + RxJava ，因此打算好好研究下 OkHttp 的源码(基于 OkHttp3.14.1)，记录一下。注：<a href="https://github.com/square/okhttp" target="_blank" rel="noopener">仓库地址</a><a id="more"></a></p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>这里只例举基本的同步方式的 Get 请求，详细的请看<a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">官方文档</a>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">syncGet</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> request = Request.Builder().url(URL).build()</span><br><span class="line">    <span class="keyword">val</span> call = client.newCall(request)</span><br><span class="line">    <span class="keyword">val</span> response = call.execute()</span><br><span class="line">    <span class="keyword">if</span> (response.isSuccessful) &#123;</span><br><span class="line">        println(<span class="string">"Response is successful"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可知，发送一个基本的 get 请求需要如下几步：</p>
<ol>
<li>创建 OkHttpClient 实例。</li>
<li>创建 Request 实例。</li>
<li>创建 Call 实例。</li>
<li>执行 Call.execute 方法。</li>
</ol>
<p>下面按照这四步探索下源码实现。</p>
<h2 id="OkHttpClient-实例的创建"><a href="#OkHttpClient-实例的创建" class="headerlink" title="OkHttpClient 实例的创建"></a>OkHttpClient 实例的创建</h2><p>首先看看 OkHttpClient 的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OkHttpClient(Builder builder) &#123;</span><br><span class="line">    <span class="comment">// 主要是从 builder 中取出对应字段进行赋值，忽略</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其拥有两个构造器不过我们只能直接调用无参的那个，另一个主要给 Builder 的 build 方法使用的(典型的建造者模式)，接着看看 Builder 的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建异步执行策略</span></span><br><span class="line">    dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">    <span class="comment">// 默认协议列表Http1.1、Http2.0</span></span><br><span class="line">    protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">    <span class="comment">// 连接规格，包括TLS(用于https)、CLEARTEXT(未加密用于http)</span></span><br><span class="line">    connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">    <span class="comment">// 事件监听，默认没有</span></span><br><span class="line">    eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">    <span class="comment">// 代理选择器</span></span><br><span class="line">    proxySelector = ProxySelector.getDefault();</span><br><span class="line">    <span class="comment">// 使用空对象设计模式</span></span><br><span class="line">    <span class="keyword">if</span> (proxySelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">        proxySelector = <span class="keyword">new</span> NullProxySelector();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 提供Cookie策略的持久性</span></span><br><span class="line">    cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">    <span class="comment">// socket工厂</span></span><br><span class="line">    socketFactory = SocketFactory.getDefault();</span><br><span class="line">    <span class="comment">// hostname验证器</span></span><br><span class="line">    hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">    <span class="comment">// 证书标签</span></span><br><span class="line">    certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">    <span class="comment">// 代理认证</span></span><br><span class="line">    proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">    <span class="comment">// 认证</span></span><br><span class="line">    authenticator = Authenticator.NONE;</span><br><span class="line">    <span class="comment">// 连接池</span></span><br><span class="line">    connectionPool = <span class="keyword">new</span> ConnectionPool();</span><br><span class="line">    <span class="comment">// dns</span></span><br><span class="line">    dns = Dns.SYSTEM;</span><br><span class="line">    <span class="comment">// 跟随ssl重定向</span></span><br><span class="line">    followSslRedirects = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 跟随重定向</span></span><br><span class="line">    followRedirects = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 当连接失败时尝试</span></span><br><span class="line">    retryOnConnectionFailure = <span class="keyword">true</span>;</span><br><span class="line">    callTimeout = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 连接、读取、写超时10秒</span></span><br><span class="line">    connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">    readTimeout = <span class="number">10_000</span>;</span><br><span class="line">    writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">    pingInterval = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Builder(OkHttpClient okHttpClient) &#123;</span><br><span class="line">    <span class="comment">// 拷贝构造器</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Builder 中的属性到用到时再好好的研究，接着来看看第二步 Request 实例的创建。</p>
<h2 id="Request-实例的创建"><a href="#Request-实例的创建" class="headerlink" title="Request 实例的创建"></a>Request 实例的创建</h2><p>Request 实例通过 Builder 进行创建的，因此首先看看 Request.Builder 的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.method = <span class="string">"GET"</span>;</span><br><span class="line">    <span class="keyword">this</span>.headers = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line">&#125;</span><br><span class="line">Builder(Request request) &#123;</span><br><span class="line">    <span class="keyword">this</span>.url = request.url;</span><br><span class="line">    <span class="keyword">this</span>.method = request.method;</span><br><span class="line">    <span class="keyword">this</span>.body = request.body;</span><br><span class="line">    <span class="keyword">this</span>.tags = request.tags.isEmpty()</span><br><span class="line">            ? Collections.emptyMap()</span><br><span class="line">            : <span class="keyword">new</span> LinkedHashMap&lt;&gt;(request.tags);</span><br><span class="line">    <span class="keyword">this</span>.headers = request.headers.newBuilder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其提供了两个构造器，不过我们只能调用无参的那个，其内部设置了默认请求方法为 GET，并且创建了一个HeaderBuilder 实例用于统一管理请求头，第二个构造器用于 Request 实例中拷贝出对应参数赋值给当前 Builder实例，接着看看其 url 方法和 build 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">url</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"url == null"</span>);</span><br><span class="line">    <span class="comment">// 默默的将web socket urls替换成http urls</span></span><br><span class="line">    <span class="keyword">if</span> (url.regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, <span class="string">"ws:"</span>, <span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">        url = <span class="string">"http:"</span> + url.substring(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, <span class="string">"wss:"</span>, <span class="number">0</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">        url = <span class="string">"https:"</span> + url.substring(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url(HttpUrl.get(url));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">url</span><span class="params">(HttpUrl url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"url == null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"url == null"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Request(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Request(Builder builder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.url = builder.url;</span><br><span class="line">    <span class="keyword">this</span>.method = builder.method;</span><br><span class="line">    <span class="keyword">this</span>.headers = builder.headers.build();</span><br><span class="line">    <span class="keyword">this</span>.body = builder.body;</span><br><span class="line">    <span class="keyword">this</span>.tags = Util.immutableMap(builder.tags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 url 方法主要是将请求地址封装成 HttpUrl 实例并赋值给成员 url，build 方法创建了 Request 实例。至此第二步结束了接着看看第三步 Call 实例的创建。</p>
<h2 id="Call-实例的创建"><a href="#Call-实例的创建" class="headerlink" title="Call 实例的创建"></a>Call 实例的创建</h2><p>通过调用 OkHttpClient 实例的 newCall() 创建 Call 实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.transmitter = <span class="keyword">new</span> Transmitter(client, call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Transmitter</span><span class="params">(OkHttpClient client, Call call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">    <span class="keyword">this</span>.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());</span><br><span class="line">    <span class="keyword">this</span>.call = call;</span><br><span class="line">    <span class="keyword">this</span>.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    <span class="keyword">this</span>.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newCall 方法返回了一个 RealCall 实例，并且初始化了其 transmitter 属性，而在 Transmitter 构造器中又初始化了 connectionPool、eventListener 属性，执行 timeout 方法，设置整次调用超时时间（包括连接、读写）默认为 0 ，其中 Internal.instance 在 OkHttpClient 这个类一加载时就初始化了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Internal.instance = <span class="keyword">new</span> Internal() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RealConnectionPool <span class="title">realConnectionPool</span><span class="params">(ConnectionPool connectionPool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connectionPool.delegate;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Transmitter.connectionPool 就是 RealConnectionPool 实例，而 Transmitter.eventListener 默认为 EventListener.NONE 。</p>
<h2 id="Call-execute"><a href="#Call-execute" class="headerlink" title="Call.execute"></a>Call.execute</h2><p>我们知道 call 其实是一个 RealCall 实例，因此看看其 execute 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.timeoutEnter();</span><br><span class="line">    transmitter.callStart();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> getResponseWithInterceptorChain();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Transmitter</span><span class="params">(OkHttpClient client, Call call)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AsyncTimeout timeout = <span class="keyword">new</span> AsyncTimeout() &#123;</span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">timedOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutEnter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        timeout.enter();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callStackTrace = Platform.get().getStackTraceForCloseable(<span class="string">"response.body().close()"</span>);</span><br><span class="line">        eventListener.callStart(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">        runningSyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始计时，当超时后会执行 AsyncTimeout.timeout 方法，不过默认超时时间为 0 ，所以不会超时，至于 <code>callStart</code> 方法回调 <code>eventListener.callStart</code>  方法。然后执行 <code>client.dispatcher().executed</code> ，将 RealCall 实例放入 <code>runningSyncCalls</code> 这个双端队列中去，最后执行 <code>getResponseWithInterceptorChain</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line">    <span class="comment">// 责任链设计模式</span></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line">    <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Response response = chain.proceed(originalRequest);</span><br><span class="line">        <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">            closeQuietly(response);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        calledNoMoreExchanges = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">            transmitter.noMoreExchanges(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法首先将用户设置的所有 Interceptor 与框架自己的几个 Interceptor 进行组合，注意用户可以设置 interceptors、networkInterceptors 前者在网络连接前执行，后者会在网络连接后执行，然后创建RealInterceptorChain 实例调用其 proceed方法获取到 Response，因此网络请求的主要逻辑就是在这个 proceed 方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, Transmitter transmitter, @Nullable Exchange exchange)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 默认index = 0，如果index超出了拦截器的总长就抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    calls++;</span><br><span class="line">    <span class="comment">// 这里刚才传入的exchange为null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.exchange.connection().supportsUrl(request.url())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">                + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">                + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 又创建了一个RealInterceptorChain实例，不过其index在原来基础上加了1</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">            index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">    <span class="comment">// 取出一个Interceptor实例调用其intercept方法</span></span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">                + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果Interceptor返回了null那么抛出NPE</span></span><br><span class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法内部主要从 interceptors 中取出 index 位置上的一个 Interceptor 实例，然后创建一个 index=index+1 的 RealInterceptorChain 实例 next，最后调用 Interceptor 实例的 interceptor 方法将 next 传入，获取到 Response 返回，那么网络请求重点其实在 interceptor.intercept 方法内，而默认 index 等于0，我们的 OkHttpClient 自己又没有设置 Interceptor，于是会调用到 RetryAndFollowUpInterceptor (负责失败重试以及重定向)实例的 intercept 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        transmitter.prepareToConnect(request);</span><br><span class="line">        <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Response response;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = realChain.proceed(request, transmitter, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 表示请求成功但是可能是一个重定向响应</span></span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">            <span class="comment">// 尝试路由连接失败，请求还没发送，判断是否需要进行重试</span></span><br><span class="line">            <span class="keyword">if</span> (!recover(e.getLastConnectException(), transmitter, <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.getFirstConnectException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 试图与服务器通信失败，请求可能已经发送，判断是否需要进行重试</span></span><br><span class="line">            <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">            <span class="keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果请求没有成功则释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                transmitter.exchangeDoneDueToException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果上个响应存在(表示上个响应是一个重定向响应，其不会拥有响应体)，构建一个新的Response实例</span></span><br><span class="line">        <span class="comment">// 将上个响应赋值给priorResponse属性</span></span><br><span class="line">        <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                            .body(<span class="keyword">null</span>)</span><br><span class="line">                            .build())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 暂时不理解这个exchange是干什么用的？？</span></span><br><span class="line">        Exchange exchange = Internal.instance.exchange(response);</span><br><span class="line">        Route route = exchange != <span class="keyword">null</span> ? exchange.connection().route() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 根据响应头判断是否是重定向，如果是就会新建一个Request实例返回</span></span><br><span class="line">        Request followUp = followUpRequest(response, route);</span><br><span class="line">        <span class="comment">// 如果followUp为空也就是没有重定向那么直接返回响应</span></span><br><span class="line">        <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exchange != <span class="keyword">null</span> &amp;&amp; exchange.isDuplex()) &#123;</span><br><span class="line">                transmitter.timeoutEarlyExit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        RequestBody followUpBody = followUp.body();</span><br><span class="line">        <span class="comment">// 如果限制只发送一次，那也直接返回响应</span></span><br><span class="line">        <span class="keyword">if</span> (followUpBody != <span class="keyword">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        closeQuietly(response.body());</span><br><span class="line">        <span class="keyword">if</span> (transmitter.hasExchange()) &#123;</span><br><span class="line">            exchange.detachWithViolence();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重定向请求太多了，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 赋值新建的请求，保存上一个响应，最终的响应会包含所有前面重定向的响应</span></span><br><span class="line">        request = followUp;</span><br><span class="line">        priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareToConnect</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.request != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sameConnection(<span class="keyword">this</span>.request.url(), request.url()) &amp;&amp; exchangeFinder.hasRouteToTry()) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// Already ready.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exchangeFinder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            maybeReleaseConnection(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">            exchangeFinder = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.request = request;</span><br><span class="line">    <span class="keyword">this</span>.exchangeFinder = <span class="keyword">new</span> ExchangeFinder(<span class="keyword">this</span>, connectionPool, createAddress(request.url()), call, eventListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会执行 <code>transmitter.prepareToConnect</code> 由于最初 <code>request</code> 为 null ，只是赋值了 <code>request</code> 和 <code>exchangeFinder</code> 字段，接着执行 <code>realChain.proceed</code> 调用下层 Interceptor 实例的 intercept 方法，当下层 Interceptor 抛出异常会判断是否有重试的必要。 当下层返回了一个 Response ，其会根据该 Response 判断是否为重定向响应，如果是就会新建一个 Request 实例，再次请求获取到新的 Response 实例后将原先的 Response赋值给其 priorResponse 属性，以此循环直到请求成功(不再重定向)、超出最大重定向数、抛出不可重试的异常。然后看看 BridgeInterceptor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CookieJar cookieJar;</span><br><span class="line">    <span class="comment">// 这里的CookieJar就是OkHttpClient的CookieJar，默认是一个空实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BridgeInterceptor</span><span class="params">(CookieJar cookieJar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cookieJar = cookieJar;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request userRequest = chain.request();</span><br><span class="line">        Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">        RequestBody body = userRequest.body();</span><br><span class="line">        <span class="comment">// 如果有请求体，并且请求头如果没有Content-Type、Content-length、Host、Connection就加上</span></span><br><span class="line">        <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">            MediaType contentType = body.contentType();</span><br><span class="line">            <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">            <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">                requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">                requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">                requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后如果没有Accept-Encoding请求头并且不是请求部分资源，那么加上Accept-Encoding: gzip</span></span><br><span class="line">        <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">            requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从cookieJar中取出Cookie列表</span></span><br><span class="line">        List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">        <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有UserAgrent就添加为okhttp/3.14.1</span></span><br><span class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用下一个Interceptor</span></span><br><span class="line">        Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">        <span class="comment">// 使用cookieJar保存cookie</span></span><br><span class="line">        HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line">        Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">                .request(userRequest);</span><br><span class="line">        <span class="keyword">if</span> (transparentGzip</span><br><span class="line">                &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">                &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">            <span class="comment">// 设置对应的响应头</span></span><br><span class="line">            GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">            Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">                    .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">                    .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            responseBuilder.headers(strippedHeaders);</span><br><span class="line">            String contentType = networkResponse.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">            <span class="comment">// 自动进行解压，不过contentLength变成了-1</span></span><br><span class="line">            responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">cookieHeader</span><span class="params">(List&lt;Cookie&gt; cookies)</span> </span>&#123;</span><br><span class="line">        StringBuilder cookieHeader = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = cookies.size(); i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cookieHeader.append(<span class="string">"; "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Cookie cookie = cookies.get(i);</span><br><span class="line">            cookieHeader.append(cookie.name()).append(<span class="string">'='</span>).append(cookie.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cookieHeader.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BridgeInterceptor 的逻辑很清晰，其做为应用程序代码与网络代码中间的桥梁，首先根据给用户的 Request 实例创建一个添加了某些请求头的 Request 实例；其次调用了 chain.proceed 执行下一个拦截器；最后将下层返回的 Response 实例构建成用户需要的 Response 实例，此外上述代码还告诉我们如果想要持久化管理 cookie 可以实现 CookieJar 这个接口设置给 OkHttpClient ，接着继续看看下一层 CacheInterceptor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个cache就是OkHttpClient里面的internalCache</span></span><br><span class="line">    <span class="keyword">final</span> InternalCache cache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheInterceptor</span><span class="params">(@Nullable InternalCache cache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果给OkHttpClient设置了InternalCache，那么从里面获取缓存的响应</span></span><br><span class="line">        Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">                ? cache.get(chain.request())</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 这个里面主要是根据请求和缓存的响应判断缓存是否命中</span></span><br><span class="line">        CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">        Request networkRequest = strategy.networkRequest;</span><br><span class="line">        Response cacheResponse = strategy.cacheResponse;</span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cache.trackResponse(strategy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            closeQuietly(cacheCandidate.body());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 客户端设置了only-if-cached，表示只使用缓存而缓存又没有命中因此直接构建一个Response返回</span></span><br><span class="line">        <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">                    .request(chain.request())</span><br><span class="line">                    .protocol(Protocol.HTTP_1_1)</span><br><span class="line">                    .code(<span class="number">504</span>)</span><br><span class="line">                    .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">                    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缓存命中，构造一个Response实例并将去掉了body的cacheResponse赋值给该实例的cacheResponse属性</span></span><br><span class="line">        <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">                    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            networkResponse = chain.proceed(networkRequest);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 发生了异常需要将缓存响应体关闭</span></span><br><span class="line">            <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                closeQuietly(cacheCandidate.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有缓存响应并且响应码是304，就根据返回的响应和缓存的响应构造一个新的响应并且更新下缓存</span></span><br><span class="line">        <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">                Response response = cacheResponse.newBuilder()</span><br><span class="line">                        .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                        .networkResponse(stripBody(networkResponse))</span><br><span class="line">                        .build();</span><br><span class="line">                networkResponse.body().close();</span><br><span class="line">                cache.trackConditionalCacheHit();</span><br><span class="line">                cache.update(cacheResponse, response);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                closeQuietly(cacheResponse.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应码不是304，则构造一个新的Response将cacheResponse、networkResponse分别去掉body赋值给</span></span><br><span class="line">        <span class="comment">// cacheResponse和networkResponse</span></span><br><span class="line">        Response response = networkResponse.newBuilder()</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .networkResponse(stripBody(networkResponse))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">                <span class="comment">// 将最终响应放到cache中</span></span><br><span class="line">                CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">                <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cache.remove(networkRequest);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(<span class="keyword">long</span> nowMillis, Request request, Response cacheResponse)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.nowMillis = nowMillis;</span><br><span class="line">            <span class="keyword">this</span>.request = request;</span><br><span class="line">            <span class="keyword">this</span>.cacheResponse = cacheResponse;</span><br><span class="line">            <span class="comment">// 根据缓存响应头提取出一些缓存有关的信息</span></span><br><span class="line">            <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.sentRequestMillis = cacheResponse.sentRequestAtMillis();</span><br><span class="line">                <span class="keyword">this</span>.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();</span><br><span class="line">                Headers headers = cacheResponse.headers();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = headers.size(); i &lt; size; i++) &#123;</span><br><span class="line">                    String fieldName = headers.name(i);</span><br><span class="line">                    String value = headers.value(i);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"Date"</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">                        servedDate = HttpDate.parse(value);</span><br><span class="line">                        servedDateString = value;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Expires"</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">                        expires = HttpDate.parse(value);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Last-Modified"</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">                        lastModified = HttpDate.parse(value);</span><br><span class="line">                        lastModifiedString = value;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"ETag"</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">                        etag = value;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Age"</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">                        ageSeconds = HttpHeaders.parseSeconds(value, -<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CacheStrategy candidate = getCandidate();</span><br><span class="line">    <span class="keyword">if</span> (candidate.networkRequest != <span class="keyword">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了onlyIfCached那么在CacheInterceptor的intercept方法内部会直接构造一个响应码为504的Response</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有缓存响应就直接创建一个没响应的CacheStrategy实例</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 丢弃缓存响应，如果请求是https并且缺少必要的握手</span></span><br><span class="line">    <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不应该使用缓存也丢弃缓存响应</span></span><br><span class="line">    <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CacheControl requestCaching = request.cacheControl();</span><br><span class="line">    <span class="comment">// 如果Request包含noCache请求头，或者带上了 If-Modified-Since、If-None-Match两个请求头也丢弃响应</span></span><br><span class="line">    <span class="comment">// 应该带上这两个请求头表示客户端在询问服务端资源是否发生变化，没变化会返回304，因此不应该使用缓存</span></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line">    <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">    <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据时间判断是否缓存命中，不知道具体是怎么判断的？</span></span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"110 HttpURLConnection \"Response is stale\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"113 HttpURLConnection \"Heuristic expiration\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加If-None-Match、If-Modified-Since请求头</span></span><br><span class="line">    String conditionName;</span><br><span class="line">    String conditionValue;</span><br><span class="line">    <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">"If-None-Match"</span>;</span><br><span class="line">        conditionValue = etag;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">"If-Modified-Since"</span>;</span><br><span class="line">        conditionValue = lastModifiedString;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">"If-Modified-Since"</span>;</span><br><span class="line">        conditionValue = servedDateString;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</span><br><span class="line">    Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line">    Request conditionalRequest = request.newBuilder()</span><br><span class="line">            .headers(conditionalRequestHeaders.build())</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CacheInterceptor 的主要功能就是从 InternalCache 中取出保存的响应，然后根据请求和缓存的响应判断缓存是否命中，命中就会直接构建一个新的响应返回，如果没命中(由于响应过期)，则会根据缓存响应的 ETag、LastModify 等响应头去构造当前的请求头，这样当服务器判断资源没变化时可以直接返回 304，框架也只需要更新下缓存的响应头就可以直接返回了。OkHttp 为我们提供了一个 Cache 类(内部使用 DiskLruCache 实现)如果我们需要能够缓存只需要进行如下设置.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder().cache(Cache(cacheFile, <span class="number">50</span> * <span class="number">1000</span>)).build()</span><br></pre></td></tr></table></figure>

<p>接着看看下一个拦截器 ConnectInterceptor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectInterceptor</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        Transmitter transmitter = realChain.transmitter();</span><br><span class="line">        <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">        Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line">        <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConnectIntercept 代码很少，但是做的事情很多，其会先去 ConnectionPoll 中寻找是否有合适的RealConnection ，如果没有找到会去请求 dns 服务器获取目标 IP 再将目标 IP 封装成一个 Route 实例然后创建一个 RealConnection 接着创建 Socket 实例并发起连接如果是 Https 请求还会发起握手，校验证书，接着构建Http1ExchangeCodec 实例，最后再去构建 Exchange 实例，接着再看看 CallServerInterceptor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallServerInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> forWebSocket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallServerInterceptor</span><span class="params">(<span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Exchange exchange = realChain.exchange();</span><br><span class="line">        <span class="comment">// 根据Request生成对应的字节数组并且写入到Buffer中</span></span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">        exchange.writeRequestHeaders(request);</span><br><span class="line">        <span class="keyword">boolean</span> responseHeadersStarted = <span class="keyword">false</span>;</span><br><span class="line">        Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果请求包含请求体，写入请求体</span></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">                exchange.flushRequest();</span><br><span class="line">                responseHeadersStarted = <span class="keyword">true</span>;</span><br><span class="line">                exchange.responseHeadersStart();</span><br><span class="line">                responseBuilder = exchange.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.body().isDuplex()) &#123;</span><br><span class="line">                    exchange.flushRequest();</span><br><span class="line">                    BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                            exchange.createRequestBody(request, <span class="keyword">true</span>));</span><br><span class="line">                    request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                            exchange.createRequestBody(request, <span class="keyword">false</span>));</span><br><span class="line">                    request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                    bufferedRequestBody.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                exchange.noRequestBody();</span><br><span class="line">                <span class="keyword">if</span> (!exchange.connection().isMultiplexed()) &#123;</span><br><span class="line">                    exchange.noNewExchangesOnConnection();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exchange.noRequestBody();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (request.body() == <span class="keyword">null</span> || !request.body().isDuplex()) &#123;</span><br><span class="line">            <span class="comment">// 将Buffer中的数据写给服务端</span></span><br><span class="line">            exchange.finishRequest();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">            exchange.responseHeadersStart();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取响应头</span></span><br><span class="line">            responseBuilder = exchange.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Response response = responseBuilder</span><br><span class="line">                .request(request)</span><br><span class="line">                .handshake(exchange.connection().handshake())</span><br><span class="line">                .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">int</span> code = response.code();</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">            response = exchange.readResponseHeaders(<span class="keyword">false</span>)</span><br><span class="line">                    .request(request)</span><br><span class="line">                    .handshake(exchange.connection().handshake())</span><br><span class="line">                    .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            code = response.code();</span><br><span class="line">        &#125;</span><br><span class="line">        exchange.responseHeadersEnd(response);</span><br><span class="line">        <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(exchange.openResponseBody(response))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">                || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">            exchange.noNewExchangesOnConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">                    <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CallServerInterceptor 真正的进行了网络请求，会根据 Request 实例构建出 Http 请求，获取到 Http 响应后再构建出 HttpResponse，网络请求成功后会接着执行前几个 Interceptor 的剩余代码，这里就不看了。直接回到RealCall.execute。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.timeoutEnter();</span><br><span class="line">    transmitter.callStart();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> getResponseWithInterceptorChain();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    finished(runningSyncCalls, call);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">        idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> isRunning = promoteAndExecute();</span><br><span class="line">    <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出当一次同步请求结束后，会将 RealCall 中队列中移除，然后启动正在等待的异步请求，如果没有异步请求会回调 IdleCallback 。接着看看异步请求过程。</p>
<h2 id="Call-enqueue"><a href="#Call-enqueue" class="headerlink" title="Call.enqueue"></a>Call.enqueue</h2><p>enqueue 方法用于执行异步请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.callStart();</span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里都和 execute 一样只是最后调用了 Dispatcher 的 enqueue 方法，不过传入的是 AsyncCall 实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 将call加入到准备队列中去</span></span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">        <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">            <span class="comment">// 刚刚创建的call不是使用webSocket所以进入这里</span></span><br><span class="line">            AsyncCall existingCall = findExistingCallWithHost(call.host());</span><br><span class="line">            <span class="comment">// 目的只是为了统计每个Host有几个AsyncCall</span></span><br><span class="line">            <span class="keyword">if</span> (existingCall != <span class="keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从正在执行或者等待执行的call队列中取出host属性为host的AsyncCall实例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AsyncCall <span class="title">findExistingCallWithHost</span><span class="params">(String host)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (AsyncCall existingCall : runningAsyncCalls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (existingCall.host().equals(host)) <span class="keyword">return</span> existingCall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (AsyncCall existingCall : readyAsyncCalls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (existingCall.host().equals(host)) <span class="keyword">return</span> existingCall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            AsyncCall asyncCall = i.next();</span><br><span class="line">            <span class="comment">// 如果已经达到最大请求数64就停止执行</span></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">            <span class="comment">// 如果每个Host达到了最大请求数5个就跳过该call</span></span><br><span class="line">            <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line">            i.remove();</span><br><span class="line">            <span class="comment">// 每个端口请求计数加1</span></span><br><span class="line">            asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">            executableCalls.add(asyncCall);</span><br><span class="line">            runningAsyncCalls.add(asyncCall);</span><br><span class="line">        &#125;</span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">        AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">        <span class="comment">// 创建一个线程池，然后执行AsyncCall的execute方法</span></span><br><span class="line">        asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">executeOn</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                client.dispatcher().finished(<span class="keyword">this</span>); <span class="comment">// This call is no longer running!</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在线程池中执行</span></span><br><span class="line">        <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">        transmitter.timeoutEnter();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Response response = getResponseWithInterceptorChain();</span><br><span class="line">            signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">            responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 端口请求计数减1</span></span><br><span class="line">            client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用了 enqueue 发送网络请求，那么最终会在线程池中执行 AsyncCall 的 execute 方法，其内部实现与同步执行基本类似，注意最后会在子线程中直接调用 onResponse ，因此我们不能在 onResponse 里面直接更新 UI 。我们可以写一个 WrapCall 将 Call 进行包装这样就能实现回调在主线程了，代码如下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrapCall</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> call: Call) : Call <span class="keyword">by</span> call &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">        call.enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">                handler.post &#123;</span><br><span class="line">                    responseCallback.onFailure(call, e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">                handler.post &#123;</span><br><span class="line">                    responseCallback.onResponse(call, response)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证 handler 只会创建一次</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> handler = Handler(Looper.getMainLooper())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外界使用，只要包装下</span></span><br><span class="line"><span class="keyword">val</span> call = WrapCall(client.newCall(request))</span><br></pre></td></tr></table></figure>

<p>源码分析到这网络流程基本已经清晰，下面再来看看 OkHttp 的连接复用。</p>
<h2 id="ConnectionPoll"><a href="#ConnectionPoll" class="headerlink" title="ConnectionPoll"></a>ConnectionPoll</h2><p>首先需要连接复用需要设置请求头 Connection: Keep-Alive ，这个已经在 BridgeInterceptor 里面设置了，当然如果响应头 Connection: false ，那么连接还是不能复用，连接池的具体实现是 RealConnectionPool ，每次在 ConnectInterceptor 的 intercepte 方法都会尝试着先从连接池中取出一个连接，取不到满足条件的才会新建一个连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealConnectionPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个线程池是专门用来执行清理线程的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span> <span class="comment">/* corePoolSize */</span>,</span><br><span class="line">            Integer.MAX_VALUE <span class="comment">/* maximumPoolSize */</span>, <span class="number">60L</span> <span class="comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">"OkHttp ConnectionPool"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">// 最大空闲连接数 默认5个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxIdleConnections;</span><br><span class="line">    <span class="comment">// 最大保存存活的空闲连接时间 默认5分钟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> keepAliveDurationNs;</span><br><span class="line">    <span class="comment">// 当向连接池中加入一个连接后会执行清理操作，内部会寻找空闲时间最长的连接，如果其空闲时间</span></span><br><span class="line">    <span class="comment">// 已经超过了最长时间就会将其关闭，不然就等待指定时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">            <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">                waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (RealConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        RealConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 双端队列保存当前OkHttpClient的所有连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录了失败的路由</span></span><br><span class="line">    <span class="keyword">final</span> RouteDatabase routeDatabase = <span class="keyword">new</span> RouteDatabase();</span><br><span class="line">    <span class="comment">// 清理线程是否正在执行</span></span><br><span class="line">    <span class="keyword">boolean</span> cleanupRunning;</span><br><span class="line">    <span class="comment">// 首先创建了一个最大空闲连接为5，最大保存存活时间5分钟的连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealConnectionPool</span><span class="params">(<span class="keyword">int</span> maxIdleConnections, <span class="keyword">long</span> keepAliveDuration, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxIdleConnections = maxIdleConnections;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);</span><br><span class="line">        <span class="keyword">if</span> (keepAliveDuration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"keepAliveDuration &lt;= 0: "</span> + keepAliveDuration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取空闲连接数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">idleConnectionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connection.transmitters.isEmpty()) total++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 总共的连接数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">connectionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connections.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Transmitter调用该方法获取连接，内部判断如果连接池有连接满足条件就返回true，不然返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">transmitterAcquirePooledConnection</span><span class="params">(Address address, Transmitter transmitter,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               @Nullable List&lt;Route&gt; routes, <span class="keyword">boolean</span> requireMultiplexed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requireMultiplexed &amp;&amp; !connection.isMultiplexed()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!connection.isEligible(address, routes)) <span class="keyword">continue</span>;</span><br><span class="line">            transmitter.acquireConnectionNoEvents(connection);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个新建的连接放入到连接池中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">        <span class="comment">// 如果清理线程还没运行就开始运行</span></span><br><span class="line">        <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">            cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">            executor.execute(cleanupRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再将连接放入双端队列中去</span></span><br><span class="line">        connections.add(connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当一个连接从执行中变成了空闲时调用，该方法会唤醒清理线程</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">connectionBecameIdle</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">if</span> (connection.noNewExchanges || maxIdleConnections == <span class="number">0</span>) &#123;</span><br><span class="line">            connections.remove(connection);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            notifyAll(); <span class="comment">// Awake the cleanup thread: we may have exceeded the idle connection limit.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭所有的连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;RealConnection&gt; evictedConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">                RealConnection connection = i.next();</span><br><span class="line">                <span class="keyword">if</span> (connection.transmitters.isEmpty()) &#123;</span><br><span class="line">                    connection.noNewExchanges = <span class="keyword">true</span>;</span><br><span class="line">                    evictedConnections.add(connection);</span><br><span class="line">                    i.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (RealConnection connection : evictedConnections) &#123;</span><br><span class="line">            closeQuietly(connection.socket());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果可以清理的话就关闭Socket返回0，不然返回需要等待的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">        RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">                RealConnection connection = i.next();</span><br><span class="line">                <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    inUseConnectionCount++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                idleConnectionCount++;</span><br><span class="line">                <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">                <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">                    longestIdleDurationNs = idleDurationNs;</span><br><span class="line">                    longestIdleConnection = connection;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">                    || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">                connections.remove(longestIdleConnection);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        closeQuietly(longestIdleConnection.socket());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pruneAndGetAllocationCount</span><span class="params">(RealConnection connection, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于Http1.1这个List最多也只有一个元素</span></span><br><span class="line">        List&lt;Reference&lt;Transmitter&gt;&gt; references = connection.transmitters;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; references.size(); ) &#123;</span><br><span class="line">            Reference&lt;Transmitter&gt; reference = references.get(i);</span><br><span class="line">            <span class="keyword">if</span> (reference.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发现一个泄露的transmitter，这是一个应用程序的bug</span></span><br><span class="line">            TransmitterReference transmitterRef = (TransmitterReference) reference;</span><br><span class="line">            String message = <span class="string">"A connection to "</span> + connection.route().address().url()</span><br><span class="line">                    + <span class="string">" was leaked. Did you forget to close a response body?"</span>;</span><br><span class="line">            Platform.get().logCloseableLeak(message, transmitterRef.callStackTrace);</span><br><span class="line">            references.remove(i);</span><br><span class="line">            connection.noNewExchanges = <span class="keyword">true</span>; eviction.</span><br><span class="line">            <span class="keyword">if</span> (references.isEmpty()) &#123;</span><br><span class="line">                connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> references.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接失败时调用将失败的Route放入到RouteDatabase中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectFailed</span><span class="params">(Route failedRoute, IOException failure)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Tell the proxy selector when we fail to connect on a fresh connection.</span></span><br><span class="line">        <span class="keyword">if</span> (failedRoute.proxy().type() != Proxy.Type.DIRECT) &#123;</span><br><span class="line">            Address address = failedRoute.address();</span><br><span class="line">            address.proxySelector().connectFailed(</span><br><span class="line">                    address.url().uri(), failedRoute.proxy().address(), failure);</span><br><span class="line">        &#125;</span><br><span class="line">        routeDatabase.failed(failedRoute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不管是同步请求还是异步请求都是通过 Dispatcher 类进行分发，然后经过从上到下5个 Interceptor 才能发起请求，获取到响应后还会经过这5个拦截器然后才将结果返回到外界，典型的责任链模式与 Android 事件分发差不多 。因此 OkHttp 核心就是 Dispatcher、Intercept。</p>
<p>Dispatcher:</p>
<p>内部维护了三个双端队列（同步请求队列、异步请求队列、异步准备队列）、一个线程池（同 CacheThreadPoll ）。</p>
<ol>
<li>执行同步调用时加入到同步请求队列，请求完毕后移除，然后看看异步准备队列是否为空，不为空就请求。</li>
<li>执行异步调用时判断是否达到最大请求数量，以及最大每个 Host 请求数量，如果都不满，那么加入异步请求队列，如果某个满了，那么加入异步准备队列，当执行完毕后异步准备队列是否为空，不为空就请求。</li>
</ol>
<p>Interceptor:</p>
<ol>
<li>RetryAndFollowUpInterceptor 用于错误重试，以及重定向。</li>
<li>BridgeInterceptor 用于添加请求头(User-Agent、Connection等等)，收到响应的时候可能会进行 GZip 解压。</li>
<li>CacheInterceptor 进行缓存管理，默认不带缓存，如果需要缓存可以给 OkHttpClient 设置 cache 属性，可以使用 OkHttp 内置的 Cache 类。</li>
<li>ConnectInterceptor 进行连接，首先从连接池中取出可以复用的连接，取不到就新建一个然后通过InetAddress 获取到域名对于的IP地址，然后创建 Socket 与服务端进行连接，连接成功后如果是Https请求还会进行握手验证证书操作。</li>
<li>CallServerInterceptor 用于真正的发起请求，从 Socket 获取的输出流写入请求数据，从输入流中读取到响应数据。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/15/EventBus%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="next" title="EventBus 源码分析">
                <i class="fa fa-chevron-left"></i> EventBus 源码分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/13/Retrofit%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="Retrofit 源码分析">
                Retrofit 源码分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="何富威" />
            
              <p class="site-author-name" itemprop="name">何富威</p>
              <p class="site-description motion-element" itemprop="description">行百里者半九十</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单使用"><span class="nav-number">2.</span> <span class="nav-text">简单使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OkHttpClient-实例的创建"><span class="nav-number">3.</span> <span class="nav-text">OkHttpClient 实例的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Request-实例的创建"><span class="nav-number">4.</span> <span class="nav-text">Request 实例的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Call-实例的创建"><span class="nav-number">5.</span> <span class="nav-text">Call 实例的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Call-execute"><span class="nav-number">6.</span> <span class="nav-text">Call.execute</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Call-enqueue"><span class="nav-number">7.</span> <span class="nav-text">Call.enqueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConnectionPoll"><span class="nav-number">8.</span> <span class="nav-text">ConnectionPoll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">9.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">何富威</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
